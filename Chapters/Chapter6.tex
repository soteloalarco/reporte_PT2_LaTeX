% Chapter 6

\chapter{Implementación} % Main chapter title

\label{Chapter6} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

En este capítulo se explica la implementación del modelo de sistema propuesto en los capítulos anteriores, se generaron los escenarios de prueba pertinentes para los cuatro modelos que comprende nuestro simulador y se muestran resultados específicos por cada modelo. Por último, se definió la metodología en cómo se interconectaron estos cuatro modelos con el fin de dar por terminada la fase de implementación y con esto poder generar distintos resultados globales del simulador en el capítulo siguiente.

%----------------------------------------------------------------------------------------
%	SECTION 
%----------------------------------------------------------------------------------------

\section{Generación de una geometría estocastica}\label{generarGeoEstocastica}

Generación de Puntos de Poisson en un círculo: \newline

Para una generación de puntos en un círculo correcta que cumpla con la definición de un HPPP [Sección \ref{PPP_C4}], el número total de puntos que se formaron en el círculo siguió una variable aleatoria de Poisson, además, estos puntos se distribuyeron de acuerdo a una distribución uniforme dentro del círculo, por último, al considerar un proceso homogéneo, la densidad de los puntos fue constante.\newline

1. Número total de puntos:\newline

En primer lugar, para cumplir con la definición de HPPP, el número total de puntos tendrá que seguir una distribución de Poisson. Para esto en cada realización se generó una variable aleatoria de Poisson con tasa constante $\lambda$ y media $\lambda A$ donde $A=\pi r^{2}$. \newline

2. Ubicación de los puntos:\newline

Después, para la distribución uniforme de puntos en un círculo, se consideraron dos variables aleatorias uniformes, una que represente el radio y otra el ángulo (esto con base en las coordenadas polares).\newline

Entonces, debido a que el área aumenta de manera cuadrática con relación al radio, un punto aleatorio ubicado uniformemente en un círculo de radio $r$ tiene las coordenadas polares $[r(\sqrt{U}), 2\pi V]$, donde U y V son las dos variables aleatorias uniformes independientes, $U, V \in{[0,1]}$.

\subsection{Escenario de Prueba de PPP}

En este escenario se validó la generación de una geometría estocastica siguiendo un HPPP.\newline

En primer lugar, el número total de puntos debe seguir una distribución discreta de Poisson, esta se comprobó con la generación de la variable aleatoria Poisson en Python usando la libreria \textit{scipy} [Véase Apéndice~\ref{AppendixA}].\newline

Después, se comprobó la generación de puntos aleatorio ubicados uniformemente en un círculo de radio $r$ en coordenadas polares $[r(\sqrt{U}), 2\pi V]$.\newline

Se graficó en un círculo 2D la generación de puntos, con tasa constante $\lambda = 1x10_3$ y $r = 100$ con media $\lambda A$ donde $A=\pi r^{2}$ [\textit{véase Figura~\ref{fig:PPPCirculo1}}].

Por último, se validó que todos los puntos se generen dentro del areá del circulo, para esto se graficó de igual manera la distribución espacial de los puntos en un círculo en plano 2D pero ahora con una densidad mayor ($\lambda = 1x10_6$), de modo que se observe que los puntos rellenan toda el área del círculo [\textit{véase Figura~\ref{fig:PPPCirculo2}}].

\begin{figure}
    \centering
    \begin{minipage}{.45\linewidth}
      \includegraphics[width=\linewidth]{PPPCirculo1}
      \caption[Distribución espacial de puntos PPP en un círculo 2D]{Distribución espacial de puntos PPP con media $\lambda A$ en un círculo 2D}
      \label{fig:PPPCirculo1}
    \end{minipage}
    \hspace{.05\linewidth}
    \begin{minipage}{.45\linewidth}
      \includegraphics[width=\linewidth]{PPPCirculo2}
      \caption[Distribución espacial de puntos PPP en un círculo 2D]{Distribución espacial de puntos PPP con media $\lambda A$ en un círculo 2D}
      \label{fig:PPPCirculo2}
    \end{minipage}
\end{figure}

\break
%----------------------------------------------------------------------------------------
%	SECTION 
%----------------------------------------------------------------------------------------
\section{Generación de ganancias de canal implementando pérdidas por distancia (PLE) y desvanecimiento Rayleigh}

De acuerdo con el modelo de canal propuesto, el modelo CI (\textit{Ecuación~\ref{eqn:CI}} de \parencite{Sun2016}), este implementa pérdidas de acuerdo con la distancia y frecuencia, dado un exponente de pérdida por trayectoria (PLE) y agrega pérdidas por el desvanecimiento rápido de Rayleigh.\newline

En primera instancia, para el cálculo de la pérdida por trayectoria, se utilizó la ecuación~\ref{eqn:CI}.

Retomando lo estudiado en la Sección~\ref{DesvRayleigC2}, se tiene que cuando el desvanecimiento es tipo Rayleigh, la magnitud (amplitud) de la señal es distribuida por una variable aleatoria tipo Rayleigh pero en potencia es distribuida exponencialmente con media unitaria. \newline

La ganancia de desvanecimiento Rayleigh se modeló por medio de la generación de una variable aleatoria que siguió una distribución Rayleigh con desviación estándar unitaria, la generación de esta variable se puede ver en el Apéndice~\ref{AppendixA}.

\subsection{Escenario de Prueba de la pérdida por trayectoria}

Se propuso un escenario UMa en exteriores en un ambiente con línea de vista (LoS), entonces de acuerdo con la Tabla~\ref{tab:ModeloCI}, los parámetros válidos del modelo de canal CI en ambientes LoS, son: PLE = 2; frecuencia de operación = 2- 38GHz; rango de distancias 60- 930 m. La Figura ~\ref{fig:PerdidasCI_C6} muestra las pérdidas por trayectoria que dependen de las distancias (entre BS y UE) y frecuencias en todo el rango en el cual es válido este modelo (sin tomar en cuenta el desvanecimiento). Se observa el incremento de las pérdidas conforme aumentan la distancia y la frecuencia. \newline

\begin{figure}[th]
    \centering
    \includegraphics[scale=.6]{Figures/MODELOCI3D_1m.png}
    \decoRule
    \caption[Pérdidas por trayectoria según el Modelo CI]{Pérdidas por trayectoria según el Modelo CI}
    \label{fig:PerdidasCI_C6}
\end{figure}

\subsection{Escenario de Prueba del Modelo de canal CI}

Ahora bien, al incorporar el desvanecimiento tipo Rayleigh y las pérdidas por trayectoria, siguiendo la Tabla~\ref{tab:ParametrosGral} donde se definen los parámetros de la simulación (PLE= 2 con radio celular de 200m, en una banda de 2 GHz), se generó el histograma (pdf) de los coeficientes de canal (ganancias de canal) esperados para el simulador, véase Figura~\ref{fig:GananciasCI_C6}, se puede observar que el valor promedio de las ganancias ($h$) es de 80.35 dB. \newline

Para la generación de las ganancias $h$ se utilizó la siguiente Ecuación:\newline

\begin{equation}
    h =  10^{(\frac{-L_{p [dB]}^{CI}}{10})} \cdot \gamma\ [W]
    \label{eqn:h_canal}
\end{equation}
Donde:
\[\gamma \to ganancia\ desvanecimiento\ Rayleigh\]
\[\ L_{p [dB]}^{CI} \to \textit{Path\ Loss}\ Modelo\ CI \]

\begin{figure}[th]
    \centering
    \includegraphics[scale=.55]{Figures/CoeficientesCanalCI.png}
    \decoRule
    \caption[Ganancias de Canal Modelo CI]{Ganancias de Canal Modelo CI}
    \label{fig:GananciasCI_C6}
\end{figure}

\hfill

\break
%----------------------------------------------------------------------------------------
%	SECTION 
%----------------------------------------------------------------------------------------

\section{Esquema de acceso múltiple al medio no ortogonal, basado en potencia (PD-NOMA)}

De acuerdo con el modelo de sistema (sección~\ref{}), se propuso implementar un esquema de acceso múltiple no ortogonal (NOMA), con base en \parencite{Shahini2019}, los autores desarrollaron un esquema NOMA basado en NB-IoT por medio de un agrupamiento óptimo de los usuarios y una optimización en la asignación de recursos, de acuerdo con la maximización de la tasa de transmisión total de subida de los dispositivos MTC.\newline

\subsection{Algoritmo de Agrupación de dispositivos uRLLC  y mMTC}

Se implementó el algoritmo de agrupamiento NOMA para los dispositivos mMTC y uRLLC descrito en \parencite{Shahini2019}[\textit{véase Algorithm \ref{A1}}], este algoritmo realiza un ordenamiento conveniente con respecto al uso de la Cancelación Sucesiva de Interferencia (SIC), es decir, se ordenan los dispositivos URLLC y mMTC de acuerdo con su ganancia de canal promedio dentro de los diferentes grupos NOMA para que puedan compartir el mismo recurso espectral (subportadora) asignado a cada grupo[\textit{véase Figura~\ref{fig:NOMAgrupoexample}}]. El Algoritmo da prioridad a los dispositivos uRLLC para que obtengan los rangos más bajos. \newline

Por lo tanto, un mensaje combinado de los dispositivos mMTC y uRLLC con ruido aditivo es recibido en la BS, la BS emplea la recepción SIC de acuerdo en cómo son ordenados los dispositivos. \newline

La recepción SIC decodifica primero el mensaje del dispositivo con el rango más bajo, por consiguiente los usuarios con los rangos siguientes (o más altos) le introducen interferencia y a su vez el usuario con el rango más alto no experimenta interferencia de ninguna señal.\newline

Es importante notar que los dispositivos uRLLC tienen requerimientos de tasas de datos más altos, por lo tanto, su potencia de transmisión será mayor que la de los dispositivos mMTC. Es por esto que en cada grupo los dispositivos uRLLC tendrán los rangos más bajos y los dispositivos mMTC los más altos. De hecho, el decodificador SIC en la BS comienza a decodificar con URLLC y, en consecuencia, los dispositivos mMTC no se ven afectados por la alta interferencia de los URLLC [véase Figura NOMAgrupoexample].\newline




\begin{figure}[th]
    \centering
    \includegraphics[scale=1]{Figures/EjemploNOMAclusters}
    \decoRule
    \caption[Ejemplo ilustrativo del ordenamiento de usuarios en los grupos NOMA]{Ejemplo ilustrativo del ordenamiento de 4 usuarios uRLLC y 8 usuarios mMTC en 3 grupos NOMA}
    \label{fig:NOMAgrupoexample}
\end{figure}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%       EJEMPLO DE ALGORITMO EN LaTeX       %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Definición de variables de los algoritmos 1 y 2:\newline

\begin{itemize}
    \item U: Lista de dispositivos uRLLC
    \item M: Lista de dispositivoss mMTC
    \item S: Lista de Subportadoras s
    \item C: Lista de Grupos NOMA
    \item $R_{m}^{th}:$ Tasa objetivo del enésimo dispositivo m mMTC 
    \item $R_{u}^{th}:$ Tasa objetivo del enésimo dispositivo u uRLLC
    \item $P_{m}^{max}:$ Potencia máxima del enésimo dispositivo m mMTC 
    \item $P_{u}^{max}:$ Potencia máxima del enésimo dispositivo u uRLLC (i.e. 23dBm)
    \item $P_{m}^{s}:$ Potencia del enésimo dispositivo m mMTC 
    \item $P_{u}^{s}:$ Potencia del enésimo dispositivo u uRLLC 
    \item $h_{m}^{s}:$ Ganancia de canal del enésimo dispositivo m mMTC sobre la portadora s
    \item $h_{u}^{s}:$ Ganancia de canal del enésimo dispositivo u uRLLC sobre la portadora s
    \item ${\hat S}$: Lista de subportadoras asignadas
    \item $S_{a}^{c}$: Lista de subportadoras asignadas al enésimo cluster
    \item ${C_{ns}}$: Lista de cluster aún no asignados
\end{itemize}


\makeatletter
% Reinsert missing \algbackskip
\def\algbackskip{\hskip-\ALG@thistlm}
\makeatother

\begin{algorithm}
    \caption{Algoritmo de agrupamiento de dispositivos uRLLC y mMTC para NOMA}\label{A1}
    \hspace*{\algorithmicindent} \textbf{Entrada} $U, M, S, C, h_{m}^{s} , \ and \ h_{u}^{s} ,\forall m \in \mathcal {M} , \forall u \in \mathcal {U} , \forall s \in \mathcal {S}$  \\
    \hspace*{\algorithmicindent} \textbf{Salida} Lista de Clusters (C) con agrupamiento de dispositivos 
    \begin{algorithmic}[1]
    \Procedure{Agrupación de dispositivos uRLLC}{}\\
    Cálculo de la ganancia de canal promedio del enésimo dispositivo u\\
    ${\tilde h_{u}} =\sum \nolimits _{s \in \mathcal {S}} {h_{u}^{s}}{/_{|S|}}$\\
    Se ordenan descendentemente las ganancias de canal promedio de cada dispositivo u, i.e. $\forall u \in \mathcal {U} : {\tilde h_{1}} \geq {\tilde h_{2}} \geq \cdots \geq {\tilde h_{U}}$ 
    \For{\textbf{each} u in U}
        \If {$|U|<|C|$} 
        \State Asignar uRLLC al rango mas bajo (k=1)
        \Else
        \State Asignar uRLLC al siguiente rango (k=2) [Solo se podrán asignar hasta un segundo rango]
        \EndIf
    \EndFor
    \State Encontrar ${\tilde k}$, rango y grupo en el que se quedó la última asignación uRLLC
    \EndProcedure
    \Procedure{Agrupación de dispositivos mMTC}{${\tilde k}$}\\
    Cálculo de la ganancia de canal promedio del enésimo dispositivo u\\
    ${\tilde h_{m}} =\sum \nolimits _{s \in \mathcal {S}} {h_{m}^{s}}{/_{|S|}}$\\
    Se ordenan descendentemente las ganancias de canal promedio de cada dispositivo u, i.e. $\forall m \in \mathcal {M} : {\tilde h_{1}} \geq {\tilde h_{2}} \geq \cdots \geq {\tilde h_{M}}$ 
    \For{\textbf{each} m in M}
        \If {$|M|<|C|$} 
        \State Asignar mMTC al rango ${\tilde k}$
        \Else
        \State Asignar mMTC a los siguientes rangos \ldots
        \EndIf
    \EndFor
    \EndProcedure
    \end{algorithmic}
\end{algorithm}


\subsection{Algoritmo de Asignacion de Subportadoras}


Este algoritmo garantiza una óptima asignación de portadoras (S), de acuerdo con la maximización de la tasa total de transmisión, para los grupos NOMA. En \parencite{Shahini2019} se plantea la metodología para la asignación de subportadoras a los grupos NOMA. \newline

Cabe destacar que en \parencite{Shahini2019}, el modelo de sistema no es implementado hacia una banda de frecuencias en específico, las ganancias de las subportadoras son estadíticas por el uso de un desvanecimiento tipo Rayleigh dentro de su simulación.\newline

En nuestro caso como se ocupa un modelo de canal que depende de la frecuencia, se tuvo que escoger un PRB de 180 KHz, con un conjunto de subportadoras fijadas en una banda LTE, se escogió la banda de 2GHz, esto por el hecho de que LTE se implementa en bandas de microondas. \newline

Para cada subportadora, el mejor grupo (c*) es el que maximiza el rendimiento total, [\textit{véase Algorithm \ref{A2}}]. Luego, por consecuencia, las velocidades de datos de los dispositivos mMTC y URLLC y sus potencias de transmisión se actualizan. Durante el proceso de asignación de subportadoras, los clústeres asignados se excluyen del conjunto de Cns. \newline

El algoritmo asigna iterativamente las subportadoras disponibles una por una. Dado que cada dispositivo MTC divide por igual su potencia de transmisión máxima entre todas las subportadoras asignados, las potencias de transmisión de los dispositivos MTC a través de las diferentes subportadoras no son óptimas utilizando el algoritmo planteado. \newline

La fase de asignación de recursos termina hasta que las 48 subportadoras se asignan a los 48 clústeres NOMA, esto del hecho que se adapta para una transmisión singletone. \newline



\begin{figure}[th]
    \centering
    \includegraphics[scale=.5]{Figures/PD_NOMA_Cluster.png}
    \decoRule
    \caption[Ejemplo ilustrativo de la distribución de potencia para PD-NOMA en \textit{Multitone}]{Ejemplo ilustrativo de la distribución de potencia para PD-NOMA en \textit{Multitone}}
    \label{fig:NOMAgrupoexample}
\end{figure}


\begin{algorithm}
    \caption{Algoritmo de asignación de recursos para NOMA}\label{A2}
    \hspace*{\algorithmicindent} \textbf{Entrada} $U, M, S, C , R_{m}^{th} , R_{u}^{th} , P_{m}^{max} , P_{u}^{max} , h_{m}^{s} , \ and \ h_{u}^{s} ,\forall m \in \mathcal {M} , \forall u \in \mathcal {U} , \forall s \in \mathcal {S}$  \\
    \hspace*{\algorithmicindent} \textbf{Salida} Asignaciones de grupos con subportadoras (Asignación de todas las subportadoras [48, NB-IoT singletone]) 
    \begin{algorithmic}[1]
    \Procedure{Asignación de subportadoras}{}\\
    $Inicialización: $ \\${R_{u}} = 0 , {R_{m}} = 0 , p_{m}^{s}=P_{m}^{max} \ y \ p_{u}^{s}= P_{u}^{max} , \forall m \in \mathcal {M} , \forall u \in \mathcal {U} , \forall s \in \mathcal {S}.$ 
    ${\hat S} \leftarrow \emptyset,~~S_{a}^{c} \leftarrow \emptyset,~~{C_{ns}} \leftarrow \mathcal {C}$ 
    \While{$\mathcal{S} \ne \emptyset$}{}
    \BState \emph{Asignación de una subportadora a un grupo NOMA}:
        \For{\textbf{each} s in S}{
        \State Seleccionar al mejor cluster $c^{*}$ (el que maximiza el throughput):
        \State ${c^{*}} = \mathop {\arg \max }\limits _{c \in {C_{ns}}} \left ({{\sum \nolimits _{u \in \mathcal {U}} {R_{u} + \sum \nolimits _{m \in \mathcal {M}} {R_{m}} } } }\right) ;$ 
        \State donde: Ru \textit{(Ecuación \ref{eqn:Ru})} y Rm \textit{(Ecuación \ref{eqn:Rm})}, de acuerdo con \parencite{Shahini2019}
        \State $Asignar\ la\ subportadora\ s\ con\ c^{*} :$ 
        \State $Actualizar\ S_{a}^{c^{*}}\ \leftarrow S_{a}^{c^{*}} \cup \{ s\} , \hat S \leftarrow \hat S \cup \{ s\}$ 
        \State $Actualizar\ las\ tasas: {R_{u}} = {R_{u}} + {R_{u,s}} ,\ {R_{m}} = {R_{m}} + {R_{m,s}}$ 
        \State $Actualizar\ las\ potencias\ de\ los\ URLLC\ y\ mMTC\ de\ c^{*}\ individualmente:$ 
        \State $p_{m}^{s} = \frac {p_{m}^{s}}{{\left |{ {S_{a}^{c^{*}}} }\right | + 1}} ,\ p_{u}^{s} = \frac {p_{u}^{s}}{{\left |{ {S_{a}^{c^{*}}} }\right | + 1}} , \forall s \in \mathcal {S}$ 
        \If {$ S_{a}^{c^{*}} == 1$}{
        \State ${C_{ns}} \leftarrow {C_{ns}}\backslash \{{c^{*}}\}$ 
        \EndIf}
        \EndFor}
    \EndWhile
    \BState \emph{Asignación de subportadoras restantes}:
    \If {$ C_{ns} \ne \emptyset $} { 
        \For{\textbf{each} s in S}{
            \State $\mathcal {S} \leftarrow \mathcal {S}\backslash \hat S$ 
            \State ${c^{*}} = \mathop {\arg \max }\limits _{c \in {C}} \left ({{\sum \nolimits _{u \in \mathcal {U}} {R_{u} + \sum \nolimits _{m \in \mathcal {M}} {R_{m}} } } }\right)$ 
            \State $Actualizar\ S_{a}^{c^{*}} \leftarrow S_{a}^{c^{*}} \cup \{ s\}$ 
        \EndFor}
            \State $Actualizar\ p_{m}^{s} = \frac {p_{m}^{s}}{{\left |{ {S_{a}^{c^{*}}} }\right | + 1}} ,\ p_{u}^{s} = \frac {p_{u}^{s}}{{\left |{ {S_{a}^{c^{*}}} }\right | + 1}}$ 
    \EndIf}
    \EndProcedure
    \end{algorithmic}
\end{algorithm}



\begin{algorithm}
    \caption{Modo de Operacion \textit{Multitone}}\label{euclid}
    \hspace*{\algorithmicindent} \textbf{Entrada} NumeroDispositivos\\
    \hspace*{\algorithmicindent} \textbf{Output} NumeroGrupos
    \begin{algorithmic}[1]
    \Procedure{Ejemplo de procedimiento \textit{Multitone} con kmax=4}{}
    \If {$kmax ==4$} 
        \If {$NumeroDispositivos <= 48$} 
        \Return NumeroDispositivos
        \EndIf
        \If {$NumeroDispositivos > 48\ and\ NumeroDispositivos <=96$} 
        \Return NumeroDispositivos/2
        \EndIf
        \If {$NumeroDispositivos > 96\ and\ NumeroDispositivos <= 144 $} 
        \Return NumeroDispositivos/3
        \EndIf
        \If {$NumeroDispositivos > 144\ and\ NumeroDispositivos < 192$} 
        \Return NumeroDispositivos/4
        \EndIf
        \If {$NumeroDispositivos >= 192$} 
        \Return 48
        \EndIf
    \EndIf
    \EndProcedure
    \end{algorithmic}
    \end{algorithm}

\subsection{Escenario de Prueba de NOMA}

En este escenario de pruebas, evaluamos el rendimiento del sistema del esquema NB-IoT basado en NOMA propuesto en \parencite{Shahini2019}, el cual implementó dos Algoritmos uno para la formación de grupos y otro para la asignación de recursos. \newline

Consideraron una celda con un radio de 0.5 km donde las ubicaciones de los dispositivos mMTC y URLLC se generaron aleatoriamente (de manera uniforme) dentro de la celda. Además, consideraron un solo PRB con 48 subportadoras de 3.75 kHz para las transmisiones de enlace ascendente (UL) en un intervalo de tiempo (TTI). \newline

Modelaron las ganancias de canal de los dispositivos mMTC como $h_{s}^{m} = \gamma d^{ -\beta}_{ m, s}$ (de manera similar $h_{s}^{u}$ para URLLCs), donde $\gamma$ es un valor aleatorio generado por la PDF de Rayleigh, $d_{-\beta}^{m,s}$ representa la distancia entre el UE y la BS, y $\beta$ es el PLE el cual lo establecieron en $\beta = 3$ y $d$ varía entre 0.1 y 500 m. \newline

También, consideraron el ruido gaussiano blanco aditivo $(AWGN)$ con una densidad espectral de potencia de $-173 dBm / Hz$. Los presupuestos de potencia de transmisión máxima de todos los dispositivos URLLC y mMTC, $Pmax ^{u}$ y $Pmax ^{m}$ ($\forall m \in \mathcal {M} , \forall u \in \mathcal {U}$), se establecen en 23 dBm. Los umbrales de velocidad de datos de los dispositivos mMTC siguen una distribución uniforme, es decir, $R_{th}^{ m} = Uniforme (0.1, 2) kb / s$, $R_{th}^{u} = Uniforme (0.1, 20) kb / s$.\newline

Los autores en \parencite{Shahini2019} proponen la oportunidad de asignar más de una subportadora (\textit{multitone}) por grupo NOMA en transmisiones con anchos de banda UL de 3.75KHz para NB-IoT. Entonces, aunque aún no ha sido especificado la asignación de múltiples subportadoras por cluster en anchos de banda de 3.75KHz para NB-IoT, se tomó la propuesta de \parencite{Shahini2019} en este simulador. \newline

Cabe destacar que no necesariamente deben coincidir nuestros resultados con los del artículo ya que se tomaron algunas consideraciones diferentes a la de ellos. En la implementación del Algoritmo \ref{A2} se percató que los autores \parencite{Shahini2019} siempre buscan alcanzar la tasa objetivo de cada dispositivo uRLLC y mMTC en cada cluster haciendo la agregación de multiples subportadoras a cada clúster, el problema que surge con esto, es que muchas de las veces que se corría la simulación, la mayoría de las subportadoras se asignaban de entre 1 - 3 clusters esto porque parecía difícil cumplir con las tasas de todos los dispositivos en estos grupos, dejando a los otros grupos sin subportadora. La modificación que se implementó es que siempre se logre asignar una subportadora para cada grupo aunque sus dispositivos no alcancen su tasa objetivo, es decir se adoptó un número fijo de grupos NOMA igual a 48. \newline

Se intentó aplicar una transmisión \textit{multitone} de otro modo, analizemos el siguiente ejemplo: \newline

En un TTI, 50 dispositivos desean transmitir, en un modo \textit{singletone} se crearían siempre 48 grupos, entonces, 48 usuarios se agruparían en el primer rango de cada grupo y los otros dos restantes se agruparían en el segundo rango de los dos primeros grupos. En este caso no puede hacerse \textit{multitone} ya que las 48 subportadoras son ocupadas por cada grupo NOMA. \newline

Ahora bien, un modo \textit{multitone} se podría aplicar de la siguiente manera, si se consideran de igual manera 50 dispositivos queriendo transmitir, estos se pueden dividir en dos grupos de 25 dispositivos, es decir crear 25 grupos con su primer y segundo rangos completos, esto con la finalidad de que las 23 subportadoras restantes se agreguen en los grupos donde sus dispositivos aún no alcanzan su tasa objetivo, esto se implementó siguiendo la metodología del $Algorithm$ \ref{A3}. \newline

Al comparar los resultados entre \textit{multitone} y \textit{singletone} en la Figura XXX se puede que el desempeño de ambos es similar, solo un caso, y es cuando el número de dispositivos es menor al número de clusters, es decir, en un modo \textit{singletone}.\newline

\begin{figure}[th]
    \centering
    \includegraphics[scale=.7]{Figures/NOMA_results_comparation.png}
    \decoRule
    \caption[]{}
    \label{fig:ResultsNOMA}
\end{figure}

El impacto de la agregación de las subportadoras solo beneficia a aquellos dispositivos que tienen una buena condición de canal o que están en los últimos rangos (ya que experimentan menos interferencia). \newline

Se estudió de igual manera el impacto de \textit{multitone} con diferentes clases de potencia para los dispositivos MTC con $kmax = 4$ y su desempeño no resultó ser favorable. Igualmente, se evaluó el desempeño con diferentes tamaños de grupos. Por ese motivo esos resultados no se reportaron.\newline

Como se observa, no se logran satisfacer todos los requisitos de velocidad de datos de los dispositivos mMTC y URLLC pero si se incrementa significativamente la conectividad de usuarios en comparación con OFDMA donde solo se puede dar servicio a un usuario por subportadora, lo que son 48 usuarios.\newline


\begin{figure}[th]
    \centering
    \includegraphics[scale=.7]{Figures/NOMA_sumrate.png}
    \decoRule
    \caption[]{}
    \label{fig:ResultsNOMA}
\end{figure}

\begin{figure}[th]
    \centering
    \includegraphics[scale=.7]{Figures/CoeficientesCanalShahini}
    \decoRule
    \caption[]{}
    \label{fig:CoeficientesCanalShahini}
\end{figure}





\hfill

\break

%----------------------------------------------------------------------------------------
%	SECTION 
%----------------------------------------------------------------------------------------

\section{Generación de Tráfico Fuente}
La generación de tráfico fuente requirió de un paradigma distinto al de eventos discretos, pues como se deja ver en el diagrama de la \textit{figura~\ref{fig:CMMPP_Algoritmo}}, un avance periódico en el tiempo es necesario para calcular las matrices de cambio de estado en los dispositivos y generar así el tráfico CMMPP, de esta manera el algoritmo de generación de tráfico fuente sigue un paradigma de simulación normalmente llamado \textit{time driven}. Adicional a este algoritmo se anexó la lógica para generar tráfico periódico en los dispositivos que así lo requirieran, teniendo así dos posibles modelos. Tal algoritmo corresponde al \textit{algoritmo \ref{A2}}. \newline

El programa Generador de Tráfico IoT se trata de la interconexión entre el algoritmo de distribución de usuarios, tratado en [6.1] y el de generación de tráfico fuente tratado en esta sección. A este programa se agrega una interfaz gráfica para facilitar la introducción de los parámetros que se consideran para generar el tráfico IoT y  se  describe más a detalle en la sección [6.6]. \newline

En las siguientes dos secciones se muestran los parámetros que fueron implementados para caracterizar el tráfico generado por los modelos CMMPP y Periódico. \newline
\subsection{Tráfico CMMPP}
La generación de tráfico CMMPP, sigue el diseño mostrado en la \textit{figura~\ref{fig:CMMPPpropuesta}} , para el cual cada dispositivo puede estar en estado de alarma o estado normal en un instante dado. El estado normal representa la operación habitual del dispositivo y a esta la caracteriza una tasa de arribos $ \lambda_{normal}$ que representa la cantidad promedio de paquetes por segundo que un dispositivo genera al estar en este estado. El estado de alarma por otra parte representa la detección de un evento o estado de interés especial para el dispositivo. Esta detección genera un único paquete de tamaño fijo detrás del cual el dispositivo volvería a su estado de operación habitual.\newline

El cambio de estado de normal  al estado de alarma requiere primeramente de un proceso en la simulación que se encargue de generar alarmas para cada tipo de dispositivo, este proceso se caracteriza por una tasa de arribo de alarmas $ \lambda_{alarma}$. Esta tasa representa la cantidad promedio de alarmas por segundo que ocurrirán en el área de la célula, además de este parámetro se necesita especificar la velocidad a la que las alarmas se transmiten desde su lugar de origen.\newline

El siguiente proceso que propicia un cambio de estado, es el cálculo de la matriz de cambio de estado $P_n\left[k\right]$ que se lleva a cabo en cada dispositivo. La ecuación \ref{eqn:Pn} utiliza la información de cuándo y donde se produjeron eventos de alarma, además de su velocidad de propagación para determinar el momento en el que la alarma llega al dispositivo. Adicionalmente es necesario un modelo que caracterice la propagación espacial. Los modelos implementados fueron los propuestos en [A] :\newline

\begin{equation}
\delta_n = e^{-\alpha.d_{n}}
\label{eqn:dn1}
\end{equation}

\begin{equation}
    \delta_n =
    \begin{cases}
        1  & \text{si $d_n < d_{th}$} \\
        \frac{1}{2}(1-sin\frac{\pi(d_n-W)}{2(W-d_{th})}) & \text{si $d_{th}< d_n < 2W-d_{th}$}\\
        0  & \text{si $d_n > 2W-d_{th}$}
    \end{cases}
    \label{eqn:dn2}
\end{equation}

El modelo que describe la \textit{ecuación~\ref{eqn:dn1}} se trata del \textit{decaying exponential} y está pensado para simular alarmas cuyo efecto en los dispositivos se espera siga un comportamiento exponencial. Los tipos de dispositivos que utilicen este modelo deberán especificar la constante $\alpha$ que caracteriza al modelo. Por otra parte la \textit{ecuación~\ref{eqn:dn2}} se trata de una \textit{raised-cosine window}, esta función es útil para modelar alarmas que se transmiten fuertemente por cierta distancia pero que después se detienen abrúptamente. Los tipos de dispositivos que utilicen este segundo modelo deberán especificar las constantes $d_{th}$ y $W$, donde $W$ es el ancho de la ventana y $d_{th}$ es la distancia de corte. En ambas ecuaciones $d_n$ es la distancia del dispositivo al origen de la alarma.\newline

Expuesto esto, los parámetros necesarios para la generación de tráfico con el modelo CMMPP, los cuales variarán según se decida para cada tipo de dispositivo, se encuentran en la \textit{tabla~\ref{tab:ParametrosTraficoCMMPP}}.\newline

\begin{table}
    \caption{Parámetros necesarios para generar tráfico CMMPP}
    \label{tab:ParametrosTraficoCMMPP}
    \centering
    \begin{tabular}{|m{6cm}|p{10cm}|} \\ 
    \textbf{Parámetro} & \textbf{Descripción} \\ 
    \textit{Tasa de nacimiento de paquetes $\lambda_{normal}$}  & \footnotesize{ Media de nacimiento de paquetes por segundo en cada dispositivo } \\ \hline 
    \textit{Tasa de nacimiento de alarmas $\lambda_{alarma}$}  & \footnotesize{ Media de nacimiento de alarmas } \\ \hline 
    \textit{Velocidad de propagación de alarmas}  & \footnotesize{ Velocidad a la que se propaga una alarma desde su posición de origen hacia todas direcciones. } \\ \hline 
    \textit{Modelo de propagación espacial de las alarmas} & \footnotesize{ Ya sea \textit{decaying exponential} o \textit{raised-cosine window}. } \\ \hline 
    \textit{Constante 1 propagación espacial} & \footnotesize{ Si el modelo de propagación corresponde a \textit{decaying exponential}:
    se trata de la constante $\alpha$, factor de decaimiento.
    Si el modelo de propagación corresponde a \textit{raised-cosine window}:
    se trata de la constante $W$, ancho de la ventana. } \\ \hline 
    \textit{Constante 1 propagación espacial} & \footnotesize{ Si el modelo de propagación corresponde a \textit{decaying exponential}:
    esta constante no se utiliza.
    Si el modelo de propagación corresponde a \textit{raised-cosine window}:
    se trata de la constante $d_{th}$, distancia de corte. } \\ \hline 
    \end{tabular}
\end{table}

    Con lo que respecta al tamaño de los paquetes, aquellos generados a partir del estado de alarma son de 20 $bytes$ y los generados en el estado normal siguen una distribución de Pareto con $\alpha$ = 2.5, tamaño mínimo de 20 $bytes$ y máximo de $200$ bytes.\newline

\subsection{Tráfico Periódico}

La generación del tráfico periódico no requiere mas que de un parámetro, la frecuencia de nacimiento de paquetes $F_{nacimiento}$, que es inversa al periodo de nacimiento de estos mismos $T_{nacimiento}$. En la implementación además, el tiempo del primer nacimiento de cada dispositivo que siga este modelo se calcula siguiendo una distribución uniforme que genera un valor entre 0 y el periodo de nacimiento y a partir de ahí se genera un nuevo nacimiento una vez transcurrido un periodo $T_{nacimiento}$. De esta manera, la transmisión de paquetes desde distintos dispositivos del mismo tipo se encuentra distribuida uniformemente a lo largo de un periodo.\newline

La \textit{tabla~\ref{tab:ParametrosTraficoPeriodico}} muestra el parámetro necesario para generar tráfico con el modelo periódico.\newline

\begin{table}
    \caption{Parámetros necesarios para generar tráfico Periódico}
    \label{tab:ParametrosTraficoPeriodico}
    \centering
    \begin{tabular}{|m{6cm}|p{10cm}|} \\ 
    \textbf{Parámetro} & \textbf{Descripción} \\ 
    \textit{Frecuencia de nacimiento de paquetes $F_{nacimiento}$}  & \footnotesize{ Cantidad de paquetes que genera un dispositivo por segundo, inversa al periodo entre dos nacimientos $T_{nacimiento}$. } \\ \hline 
 
    \end{tabular}
\end{table}

\subsection{Escenario de Prueba de Tráfico CMMPP}


\hfill

\break

%----------------------------------------------------------------------------------------
%	SECTION 
%----------------------------------------------------------------------------------------

\section{Interconexión de los 4 módulos del Simulador}
%Incluir lo de NPRACHH, NPUCSH y NORA


\hfill

\break

%----------------------------------------------------------------------------------------
%	SECTION 
%----------------------------------------------------------------------------------------

\section{Simulador de Eventos Discretos}

\subsection{Definición de eventos}

\subsection{Interfaz de usuario del simulador de tráfico fuente}

\subsection{Descripción de los \textit{logs} de salida}

\hfill

\break

%----------------------------------------------------------------------------------------
%	SECTION 
%----------------------------------------------------------------------------------------

\section{Optimización de tiempos de simulación}

La generación de distintas variables aleatorias y el uso de algoritmos de asignación de recursos nos mantuvo en la preocupación de que los tiempos de simulación probablemente llegarán a ser excesivamente largos, por tal se propuso utilizar una técnica de paralelismo en python. Favorablemente esto no sucedió como se esperaba, el tiempo máximo de espera para una simulación rondó los 20 minutos como máximo.\newline

De cualquier forma, la técnica de paralelización si se implementó pero solamente en la generación de resultados de NOMA para un TTI ya que en esta parte fue que se necesitaron obtener resultados promedio donde cada punto o muestra de los datos necesitaba simularse 1000 repeticiones para así obtener un promedio. En la Tabla~\ref{tab:} se observa la comparación de los tiempos de simulación e un caso normal (solamente 1 núcleo en uso) e implementando la paralelización (uso de todos los núcleos de la PC).\newline

[Cabe mencionar que esta simulación se montó en una PC con procesador Intel(R) Core(TM) i7-7700HQ CPU @2.80 GHz y 16 GB de Memoria RAM.]

