% Chapter 6

\chapter{Implementación} % Main chapter title

\label{Chapter6} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

En este capítulo se explica la implementación del modelo de sistema propuesto en los capítulos anteriores, se generaron los escenarios de prueba pertinentes para los cuatro modelos que comprenden el simulador y se muestran resultados específicos por cada modelo. Por último, se definió la metodología de cómo se interconectaron estos cuatro modelos con el fin de dar por terminada la fase de implementación y con esto poder generar distintos resultados globales del simulador en el capítulo siguiente.

%----------------------------------------------------------------------------------------
%	SECTION 
%----------------------------------------------------------------------------------------

\section{Generación de una geometría estocástica}\label{generarGeoEstocastica}

Generación de Puntos PPP en un círculo: \newline

Para la generación de puntos en un círculo correcta, que cumpla con la definición de un HPPP [Sección \ref{PPP_C2}], el número total de puntos que se formaron en el círculo siguió una variable aleatoria de Poisson, además, estos puntos se distribuyeron de acuerdo a una distribución uniforme dentro del círculo, por último, al considerar un proceso homogéneo, la densidad de los puntos fue constante.\newline

1. Número total de puntos:\newline

En primer lugar, para cumplir con la definición de HPPP, el número total de puntos tendrá que seguir una distribución de Poisson. Para esto en cada realización se generó una variable aleatoria de Poisson con tasa constante $\lambda$ y media $\lambda A$ donde $A=\pi r^{2}$. \newline

2. Ubicación de los puntos:\newline

Después, para la distribución uniforme de puntos en un círculo, se generaron dos variables aleatorias uniformes, una que representa el radio y otra el ángulo (en coordenadas polares).\newline

Entonces, debido a que el área aumenta de manera cuadrática con relación al radio, un punto aleatorio ubicado uniformemente en un círculo de radio $r$ tiene las coordenadas polares $[r(\sqrt{U}), 2\pi V]$, donde U y V son las dos variables aleatorias antes mencionadas, $U, V \in{[0,1]}$.\newline

\subsection{Escenario de Prueba de PPP}

En este escenario se validó la generación de una geometría estocastica siguiendo un HPPP.\newline

En primer lugar, el número total de puntos debe seguir una distribución discreta de Poisson, esta se implementó con la libreria \textit{scipy} [Véase Apéndice~\ref{AppendixA}].\newline

Después, se comprobó la generación de puntos aleatorios ubicados uniformemente en un círculo de radio $r$ en coordenadas polares $[r(\sqrt{U}), 2\pi V]$.\newline

Se graficaron los puntos en un círculo, con tasa constante $\lambda = 1x10^{3}$ y $r = 100$ con media $\lambda A$ donde $A=\pi r^{2}$ [\textit{véase Figura~\ref{fig:PPPCirculo1}}].\newline

Por último, se validó que todos los puntos se generen dentro del areá del circulo, para esto se graficó de igual manera la distribución espacial de los puntos en un círculo en plano 2D pero ahora con una densidad mayor ($\lambda = 1x10^{6}$), de modo que se observe que los puntos rellenan toda el área del círculo de manera uniforme [\textit{véase Figura~\ref{fig:PPPCirculo2}}].\newline

\begin{figure}
    \centering
    \begin{minipage}{.45\linewidth}
      \includegraphics[width=\linewidth]{PPPCirculo1}
      \caption[Distribución espacial de puntos PPP en un círculo 2D]{Distribución espacial de puntos PPP con media $\lambda = 1x10^{3}$ y $r = 100$}
      \label{fig:PPPCirculo1}
    \end{minipage}
    \hspace{.05\linewidth}
    \begin{minipage}{.45\linewidth}
      \includegraphics[width=\linewidth]{PPPCirculo2}
      \caption[Distribución espacial de puntos PPP en un círculo 2D]{Distribución espacial de puntos PPP con media $\lambda = 1x10^{6}$ y $r = 100$}
      \label{fig:PPPCirculo2}
    \end{minipage}
\end{figure}

%----------------------------------------------------------------------------------------
%	SECTION 
%----------------------------------------------------------------------------------------
\section{Generación de ganancias de canal}

El canal propuesto, con modelo CI (\textit{Ecuación~\ref{eqn:CI}} de \parencite{Sun2016}), implementa pérdidas de acuerdo con la distancia y frecuencia, dado un exponente de pérdida por trayectoria (PLE) y agrega pérdidas por el desvanecimiento rápido de Rayleigh.\newline

En primera instancia, para el cálculo de la pérdida por trayectoria, se utilizó la ecuación~\ref{eqn:CI}.

Retomando lo estudiado en la Sección~\ref{DesvRayleigC2}, se tiene que cuando el desvanecimiento es tipo Rayleigh, la magnitud (amplitud) de la señal es distribuida por una variable aleatoria tipo Rayleigh pero en potencia es distribuida exponencialmente con media unitaria. \newline

La ganancia de desvanecimiento Rayleigh se modeló por medio de la generación de una variable aleatoria que siguió una distribución Rayleigh con desviación estándar unitaria, la generación de esta variable se puede ver en el Apéndice~\ref{AppendixA}.

\subsection{Escenario de Prueba del Modelo de canal CI}

Se propuso un escenario UMa en exteriores en un ambiente con línea de vista (LoS), entonces de acuerdo con la Tabla~\ref{tab:ModeloCI}, los parámetros válidos del modelo de canal CI en ambientes LoS, son: PLE = 2; frecuencia de operación = 2- 38GHz; rango de distancias 60- 930 m. La Figura ~\ref{fig:PerdidasCI_C6} muestra las pérdidas por trayectoria que dependen de las distancias (entre BS y UE) y frecuencias en todo el rango en el cual es válido este modelo (sin tomar en cuenta el desvanecimiento). Se observa el incremento de las pérdidas conforme aumentan la distancia y la frecuencia. \newline

\begin{figure}[th]
    \centering
    \includegraphics[scale=.6]{Figures/MODELOCI3D_1m.png}
    \decoRule
    \caption[Pérdidas por trayectoria según el Modelo CI]{Pérdidas por trayectoria según el Modelo CI}
    \label{fig:PerdidasCI_C6}
\end{figure}

Ahora bien, al incorporar el desvanecimiento tipo Rayleigh y las pérdidas por trayectoria, siguiendo la Tabla~\ref{tab:ParametrosGral} donde se definen los parámetros de la simulación (PLE= 2 con radio celular de 200m, en una banda de 2 GHz), se generó el histograma normalizado (pdf) de los coeficientes de canal (ganancias de canal) esperados para el simulador, véase Figura~\ref{fig:GananciasCI_C6}, se puede observar que el valor promedio de las ganancias ($h$) es de 80.35 dB. \newline

\begin{figure}[th]
    \centering
    \includegraphics[scale=.55]{Figures/CoeficientesCanalCI.png}
    \decoRule
    \caption[Ganancias de Canal Modelo CI]{Ganancias de Canal Modelo CI}
    \label{fig:GananciasCI_C6}
\end{figure}

\break
%----------------------------------------------------------------------------------------
%	SECTION 
%----------------------------------------------------------------------------------------

\section{Esquema de acceso múltiple al medio no ortogonal, basado en potencia (PD-NOMA)}

En el diseño del sistema se decidió implementar un esquema de acceso múltiple no ortogonal (NOMA), con base en \parencite{Shahini2019}, los autores desarrollaron un esquema NOMA basado en NB-IoT, esto se realizó por medio de dos algoritmos, un algortimo para el agrupamiento de los usuarios y otro para la asignación de recursos.

\subsection{Algoritmo de Agrupación de dispositivos uRLLC  y mMTC}

Primeramente, se implementó el algoritmo de agrupamiento NOMA para los dispositivos mMTC y uRLLC descrito en \parencite{Shahini2019}[\textit{véase Algorithm \ref{A1}}], este algoritmo realiza un ordenamiento conveniente con respecto al uso de la Cancelación Sucesiva de Interferencia (SIC), es decir, se ordenan los dispositivos URLLC y mMTC de acuerdo con su ganancia de canal promedio dentro de los diferentes grupos NOMA para que puedan compartir el mismo recurso espectral (subportadora) asignado a cada grupo[\textit{véase Figura~\ref{fig:NOMAgrupoexample}}]. El Algoritmo da prioridad a los dispositivos URLLC para que obtengan los rangos más bajos. \newline

Por lo tanto, un mensaje combinado de los dispositivos mMTC y URLLC con ruido aditivo es recibido en la BS, la BS emplea la recepción SIC de acuerdo a cómo son ordenados los dispositivos. \newline

La recepción SIC decodifica primero el mensaje del dispositivo con el rango más bajo, por consiguiente los usuarios con los rangos siguientes (o más altos) le introducen interferencia y por el contrario el usuario con el rango más alto no experimenta interferencia de ninguna señal.\newline

Es importante notar que los dispositivos URLLC tienen requerimientos de tasas de datos más altos, por lo tanto, su potencia de transmisión será mayor que la de los dispositivos mMTC. Es por esto que en cada grupo los dispositivos uRLLC tendrán los rangos más bajos y los dispositivos mMTC los más altos. De hecho, el decodificador SIC en la BS comienza a decodificar el mensaje URLLC y, en consecuencia, los dispositivos mMTC no se ven afectados por la alta interferencia [véase \textit{figura~\ref{fig:NOMAgrupoexample}}].\newline


\begin{figure}[th]
    \centering
    \includegraphics[scale=.8]{Figures/EjemploNOMAclusters}
    \decoRule
    \caption[Ejemplo ilustrativo del ordenamiento de usuarios en los grupos NOMA]{Ejemplo ilustrativo del ordenamiento de 4 usuarios uRLLC y 8 usuarios mMTC en 3 grupos NOMA}
    \label{fig:NOMAgrupoexample}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%       EJEMPLO DE ALGORITMO EN LaTeX       %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Siguiendo la definición de las variables de los algoritmos en \parencite{Shahini2019} [descritas en la Sección~\ref{VariablesSHahini}], se tiene:\newline

\makeatletter
% Reinsert missing \algbackskip
\def\algbackskip{\hskip-\ALG@thistlm}
\makeatother

\begin{algorithm}
    \caption{Algoritmo de agrupamiento de dispositivos uRLLC y mMTC para NOMA}\label{A1}
    \hspace*{\algorithmicindent} \textbf{Entrada} $U, M, S, C, h_{m}^{s} , \ and \ h_{u}^{s} ,\forall m \in \mathcal {M} , \forall u \in \mathcal {U} , \forall s \in \mathcal {S}$  \\
    \hspace*{\algorithmicindent} \textbf{Salida} Lista de Clusters (C) con agrupamiento de dispositivos 
    \begin{algorithmic}[1]
    \Procedure{Agrupación de dispositivos uRLLC}{}\\
    Cálculo de la ganancia de canal promedio del enésimo dispositivo $u$\\
    ${\tilde h_{u}} =\sum \nolimits _{s \in \mathcal {S}} {h_{u}^{s}}{/_{|S|}}$\\
    Se ordenan descendentemente las ganancias de canal promedio de cada dispositivo u, i.e. $\forall u \in \mathcal {U} : {\tilde h_{1}} \geq {\tilde h_{2}} \geq \cdots \geq {\tilde h_{U}}$ 
    \For{\textbf{each} u in U}
        \If {$|U|<|C|$} 
        \State Asignar uRLLC al rango mas bajo (k=1)
        \Else
        \State Asignar uRLLC al siguiente rango (k=2) [Solo se podrán asignar hasta un segundo rango]
        \EndIf
    \EndFor
    \State Encontrar ${\tilde k}$, rango y grupo en el que se quedó la última asignación uRLLC
    \EndProcedure
    \Procedure{Agrupación de dispositivos mMTC}{${\tilde k}$}\\
    Cálculo de la ganancia de canal promedio del enésimo dispositivo u\\
    ${\tilde h_{m}} =\sum \nolimits _{s \in \mathcal {S}} {h_{m}^{s}}{/_{|S|}}$\\
    Se ordenan descendentemente las ganancias de canal promedio de cada dispositivo u, i.e. $\forall m \in \mathcal {M} : {\tilde h_{1}} \geq {\tilde h_{2}} \geq \cdots \geq {\tilde h_{M}}$ 
    \For{\textbf{each} m in M}
        \If {$|M|<|C|$} 
        \State Asignar mMTC al rango ${\tilde k}$
        \Else
        \State Asignar mMTC a los siguientes rangos \ldots
        \EndIf
    \EndFor
    \EndProcedure
    \end{algorithmic}
\end{algorithm}


\break

\subsection{Algoritmo de Asignacion de Subportadoras}

Este algoritmo garantiza una óptima asignación de portadoras ($S$), de acuerdo con la maximización de la tasa total de transmisión, para los grupos NOMA. En \parencite{Shahini2019} se plantea la metodología para la asignación de subportadoras a los grupos NOMA. \newline

Para cada subportadora, el mejor grupo (c*) es el que maximiza el rendimiento total. Luego, por consecuencia, las velocidades de transmisión de los dispositivos mMTC y URLLC y sus potencias de transmisión se actualizan. Durante el proceso de asignación de subportadoras, los clústeres asignados se excluyen del conjunto de grupos no asignados (variable Cns). \newline

En el algoritmo \parencite{Shahini2019}, mencionan que dado que cada dispositivo MTC divide por igual su potencia de transmisión máxima entre todas las subportadoras asignadas, las potencias de transmisión de los dispositivos a través de las diferentes subportadoras no son óptimas. \newline

Durante la implementación del Algoritmo en \parencite{Shahini2019}, se notó que los autores \parencite{Shahini2019} siempre buscan alcanzar la tasa objetivo de cada dispositivo URLLC y mMTC en cada cluster haciendo la agregación de multiples subportadoras a cada clúster, el problema que surge con esto, es que muchas de las veces que se corría la simulación, la mayoría de las subportadoras se asignaban de entre 1 a 3 grupos, esto porque parecía difícil cumplir con las tasas de todos los dispositivos en estos grupos, dejando a los otros grupos sin subportadora. La modificación que se implementó fue que siempre se logre asignar una subportadora para cada grupo aunque sus dispositivos no alcancen su tasa objetivo, es decir se adoptó un número fijo de grupos NOMA igual a 48. \newline

En el algortimo implementado en este proyecto la fase de asignación de recursos termina hasta que las 48 subportadoras se asignan a los 48 grupos NOMA, esto para una transmisión \textit{singletone}. \newline

Los autores en \parencite{Shahini2019} proponen la oportunidad de asignar más de una subportadora (\textit{multitone}) por grupo NOMA en transmisiones con anchos de banda UL de 3.75KHz para NB-IoT. A pesar de que aún no ha sido especificada la asignación de múltiples subportadoras por cluster en anchos de banda de 3.75KHz para NB-IoT, se tomó la propuesta de \parencite{Shahini2019} en este simulador. \newline

Se intentó aplicar una transmisión \textit{multitone} de otro modo, analizemos el siguiente ejemplo: \newline

Si en un TTI, 50 dispositivos desean transmitir, en un modo \textit{singletone} se crearían siempre 48 grupos, entonces, 48 usuarios se agruparían en el primer rango de cada grupo y los otros dos restantes se agruparían en el segundo rango de los dos primeros grupos. En este caso no puede hacerse \textit{multitone} ya que las 48 subportadoras son ocupadas por cada grupo NOMA. \newline

Ahora bien, un modo \textit{multitone} se podría aplicar de la siguiente manera, si se consideran de igual manera 50 dispositivos queriendo transmitir, estos se pueden dividir en dos grupos de 25 dispositivos, es decir crear 25 grupos con su primer y segundo rangos completos, esto con la finalidad de que las 23 subportadoras restantes se agreguen en los grupos donde sus dispositivos aún no alcanzan su tasa objetivo, esto se implementó siguiendo la metodología del $algorithm$ \ref{A3}. \newline

En la Figura~\ref{fig:NOMAgrupoexample2} se puede observar la estrategia multitono propuesta.\newline

\begin{figure}[th]
    \centering
    \includegraphics[scale=.4]{Figures/PD_NOMA_Cluster.png}
    \decoRule
    \caption[Ejemplo ilustrativo de la distribución de potencia para PD-NOMA en \textit{Multitone}]{Ejemplo ilustrativo de la distribución de potencia para PD-NOMA en \textit{Multitone}}
    \label{fig:NOMAgrupoexample2}
\end{figure}

\begin{algorithm}
    \caption{Algoritmo de asignación de recursos para NOMA}\label{A2}
    \hspace*{\algorithmicindent} \textbf{Entrada} $U, M, S, C , R_{m}^{th} , R_{u}^{th} , P_{m}^{max} , P_{u}^{max} , h_{m}^{s} , \ and \ h_{u}^{s} ,\forall m \in \mathcal {M} , \forall u \in \mathcal {U} , \forall s \in \mathcal {S}$  \\
    \hspace*{\algorithmicindent} \textbf{Salida} Asignaciones de grupos con subportadoras (Asignación de todas las subportadoras [48, NB-IoT singletone]) 
    \begin{algorithmic}[1]
    \Procedure{Asignación de subportadoras}{}\\
    $Inicialización: $ \\${R_{u}} = 0 , {R_{m}} = 0 , p_{m}^{s}=P_{m}^{max} \ y \ p_{u}^{s}= P_{u}^{max} , \forall m \in \mathcal {M} , \forall u \in \mathcal {U} , \forall s \in \mathcal {S}.$ 
    ${\hat S} \leftarrow \emptyset,~~S_{a}^{c} \leftarrow \emptyset,~~{C_{ns}} \leftarrow \mathcal {C}$ 
    \While{$\mathcal{S} \ne \emptyset$}{}
    \BState \emph{Asignación de una subportadora a un grupo NOMA}:
        \For{\textbf{each} s in S}{
        \State Seleccionar al mejor cluster $c^{*}$ (el que maximiza el throughput):
        \State ${c^{*}} = \mathop {\arg \max }\limits _{c \in {C_{ns}}} \left ({{\sum \nolimits _{u \in \mathcal {U}} {R_{u} + \sum \nolimits _{m \in \mathcal {M}} {R_{m}} } } }\right) ;$ 
        \State donde: Ru \textit{(Ecuación \ref{eqn:Ru})} y Rm \textit{(Ecuación \ref{eqn:Rm})}, de acuerdo con \parencite{Shahini2019}
        \State $Asignar\ la\ subportadora\ s\ con\ c^{*} :$ 
        \State $Actualizar\ S_{a}^{c^{*}}\ \leftarrow S_{a}^{c^{*}} \cup \{ s\} , \hat S \leftarrow \hat S \cup \{ s\}$ 
        \State $Actualizar\ las\ tasas: {R_{u}} = {R_{u}} + {R_{u,s}} ,\ {R_{m}} = {R_{m}} + {R_{m,s}}$ 
        \State $Actualizar\ las\ potencias\ de\ los\ URLLC\ y\ mMTC\ de\ c^{*}\ individualmente:$ 
        \State $p_{m}^{s} = \frac {p_{m}^{s}}{{\left |{ {S_{a}^{c^{*}}} }\right | + 1}} ,\ p_{u}^{s} = \frac {p_{u}^{s}}{{\left |{ {S_{a}^{c^{*}}} }\right | + 1}} , \forall s \in \mathcal {S}$ 
        \If {$ S_{a}^{c^{*}} == 1$}{
        \State ${C_{ns}} \leftarrow {C_{ns}}\backslash \{{c^{*}}\}$ 
        \EndIf}
        \EndFor}
    \EndWhile
    \BState \emph{Asignación de subportadoras restantes}:
    \If {$ C_{ns} \ne \emptyset $} { 
        \For{\textbf{each} s in S}{
            \State $\mathcal {S} \leftarrow \mathcal {S}\backslash \hat S$ 
            \State ${c^{*}} = \mathop {\arg \max }\limits _{c \in {C}} \left ({{\sum \nolimits _{u \in \mathcal {U}} {R_{u} + \sum \nolimits _{m \in \mathcal {M}} {R_{m}} } } }\right)$ 
            \State $Actualizar\ S_{a}^{c^{*}} \leftarrow S_{a}^{c^{*}} \cup \{ s\}$ 
        \EndFor}
            \State $Actualizar\ p_{m}^{s} = \frac {p_{m}^{s}}{{\left |{ {S_{a}^{c^{*}}} }\right | + 1}} ,\ p_{u}^{s} = \frac {p_{u}^{s}}{{\left |{ {S_{a}^{c^{*}}} }\right | + 1}}$ 
    \EndIf}
    \EndProcedure
    \end{algorithmic}
\end{algorithm}



\begin{algorithm}
    \caption{Modo de Operacion \textit{Multitone}}\label{A3}
    \hspace*{\algorithmicindent} \textbf{Entrada} NumeroDispositivos\\
    \hspace*{\algorithmicindent} \textbf{Output} NumeroGrupos
    \begin{algorithmic}[1]
    \Procedure{Ejemplo de procedimiento \textit{Multitone} con kmax=4}{}
    \If {$kmax ==4$} 
        \If {$NumeroDispositivos <= 48$} 
        \Return NumeroDispositivos
        \EndIf
        \If {$NumeroDispositivos > 48\ and\ NumeroDispositivos <=96$} 
        \Return NumeroDispositivos/2
        \EndIf
        \If {$NumeroDispositivos > 96\ and\ NumeroDispositivos <= 144 $} 
        \Return NumeroDispositivos/3
        \EndIf
        \If {$NumeroDispositivos > 144\ and\ NumeroDispositivos < 192$} 
        \Return NumeroDispositivos/4
        \EndIf
        \If {$NumeroDispositivos >= 192$} 
        \Return 48
        \EndIf
    \EndIf
    \EndProcedure
    \end{algorithmic}
\end{algorithm}

\break

\subsection{Escenario de Prueba de NOMA}

En este escenario de pruebas, se evaluó el rendimiento del sistema del esquema NB-IoT basado en NOMA propuesto en \parencite{Shahini2019}, el cual implementó dos algoritmos: uno para la formación de grupos y otro para la asignación de recursos. \newline

Para la validación de los algoritmos, se consideró el modelo de sistema que proponen en \parencite{Shahini2019}, con el fin de poder realizar comparaciones con los resultados obtenidos en \parencite{Shahini2019}. \newline

Entonces, en su modelo de sistema, los autores en \parencite{Shahini2019} consideraron los siguiente:\newline

Una celda con un radio de 0.5 km donde las ubicaciones de los dispositivos mMTC y URLLC se generaron aleatoriamente (de manera uniforme) dentro de la celda. Además, consideraron un solo PRB con 48 subportadoras de 3.75 kHz para las transmisiones de enlace ascendente (UL) en un intervalo de tiempo (TTI). \newline

Modelaron las ganancias de canal de los dispositivos mMTC como $h_{s}^{m} = \gamma d^{ -\beta}_{ m, s}$ (de manera similar $h_{s}^{u}$ para URLLCs), donde $\gamma$ es un valor aleatorio generado por la PDF de Rayleigh, $d_{-\beta}^{m,s}$ representa la distancia entre el UE y la BS, y $\beta$ es el PLE el cual lo establecieron en $\beta = 3$ y $d$ varía entre 0.1 y 500 m. \newline

Los coeficientes de canal del modelo de sistema en \parencite{Shahini2019}, se representan en la Figura ~\ref{fig:CoeficientesCanalShahini}.

\begin{figure}[th]
    \centering
    \includegraphics[scale=.55]{Figures/CoeficientesCanalShahini}
    \decoRule
    \caption[Coeficientes de canal del modelo de sistema en \parencite{Shahini2019}]{Coeficientes de canal del modelo de sistema en \parencite{Shahini2019} }
    \label{fig:CoeficientesCanalShahini}
\end{figure}

Consideraron el ruido gaussiano blanco aditivo $(AWGN)$ con una densidad espectral de potencia de $-173 dBm / Hz$. Los presupuestos de potencia de transmisión máxima de todos los dispositivos URLLC y mMTC, $Pmax ^{u}$ y $Pmax ^{m}$ ($\forall m \in \mathcal {M} , \forall u \in \mathcal {U}$), se establecen en 23 dBm. Los umbrales de velocidad de datos de los dispositivos mMTC siguen una distribución uniforme, es decir, $R_{th}^{ m} = Uniforme (0.1, 2) kb / s$, $R_{th}^{u} = Uniforme (0.1, 20) kb / s$.\newline

Cabe destacar que no necesariamente deben coincidir nuestros resultados con los del artículo ya que se tomaron algunas consideraciones diferentes a la de ellos, explicadas en la sección anterior. Esto puede comprobarse en la \textit{figura~\ref{fig:ResultsNOMA}}, al comparar los resultados de nuestro algortimo con el de los autores en \parencite{Shahini2019}, se puede observar que nuestro algoritmo tiene un menor desempeño especialmente en los casos de 75 a 175 usuarios, empatando cuando son 192 usuarios.\newline

Además, al comparar los resultados entre \textit{multitone} y \textit{singletone} de nuestro algortimo (en la \textit{figura~\ref{fig:ResultsNOMA}}) se puede ver que el desempeño de ambos modos de transmisión es similar en la mayoría de los casos.\newline

\begin{figure}[th]
    \centering
    \includegraphics[scale=.7]{Figures/NOMA_results_comparation.png}
    \decoRule
    \caption[Escenario de pruebas de esquema NOMA]{Escenario de pruebas de esquema NOMA}
    \label{fig:ResultsNOMA}
\end{figure}

El impacto de la agregación de las subportadoras solo beneficia a aquellos dispositivos que tienen una buena condición de canal o que están en los últimos rangos (ya que experimentan menos interferencia). \newline

Se estudió de igual manera el impacto de \textit{multitone} con diferentes clases de potencia para los dispositivos MTC con $kmax = 4$ y su desempeño no resultó ser favorable. Igualmente, se evaluó el desempeño con diferentes tamaños de grupos. Por ese motivo esos resultados no se reportaron.\newline

Como se observa, no se logran satisfacer todos los requisitos de tasa de datos de los dispositivos mMTC y URLLC pero sí se incrementa significativamente la conectividad de usuarios en comparación con OFDMA donde sólo se puede dar servicio a un usuario por subportadora, lo que son 48 usuarios.\newline

En la figura~\ref{fig:ResultsNOMA2}, se muestran la comparación de resultados de la \textit{sum-rate} alcanzada de los resultados de nuestro algortimo con el de los autores en \parencite{Shahini2019}, se puede ver que en un modo multitono se alcanza mas tasa, esto es porque se agregan las subportadoras sobrantes, esto cuando el número de dispositivos es menor al número de grupos.
\begin{figure}[th]
    \centering
    \includegraphics[scale=.7]{Figures/NOMA_sumrate.png}
    \decoRule
    \caption[Segundo escenario de pruebas de esquema NOMA]{Segundo escenario de pruebas de esquema NOMA}
    \label{fig:ResultsNOMA2}
\end{figure}

\break

%----------------------------------------------------------------------------------------
%	SECTION 
%----------------------------------------------------------------------------------------

\section{Generación de Tráfico Fuente}
La generación de tráfico fuente requirió de un paradigma distinto al de eventos discretos, pues como se deja ver en el diagrama de la \textit{figura~\ref{fig:CMMPP_Algoritmo}}, un avance periódico en el tiempo es necesario para calcular las matrices de cambio de estado en los dispositivos y generar así el tráfico CMMPP, de esta manera el algoritmo de generación de tráfico fuente sigue un paradigma de simulación normalmente llamado \textit{time driven}. Adicional a este algoritmo se anexó la lógica para generar tráfico periódico en los dispositivos que así lo requirieran, teniendo así dos posibles modelos. Tal algoritmo corresponde al \textit{algoritmo \ref{generacionTrafico}}. \newline

El programa Generador de Tráfico IoT se trata de la interconexión entre el algoritmo de distribución de usuarios, tratado en \ref{generarGeoEstocastica} y el de generación de tráfico fuente tratado en esta sección. A este programa se agrega una interfaz gráfica para facilitar la introducción de los parámetros que se consideran para generar el tráfico IoT y  se  describe más a detalle en la sección \ref{generadortraficoiot}. \newline

En las siguientes dos secciones se muestran los parámetros que fueron implementados para caracterizar el tráfico generado por los modelos CMMPP y Periódico. \newline
\subsection{Tráfico CMMPP}
La generación de tráfico CMMPP, sigue el diseño mostrado en la \textit{figura~\ref{fig:CMMPPpropuesta}} , para el cual cada dispositivo puede estar en estado de alarma o estado normal en un instante dado. El estado normal representa la operación habitual del dispositivo y a esta la caracteriza una tasa de arribos $ \lambda_{normal}$ que representa la cantidad promedio de paquetes por segundo que un dispositivo genera al estar en este estado. El estado de alarma por otra parte representa la detección de un evento o estado de interés especial para el dispositivo. Esta detección genera un único paquete de tamaño fijo detrás del cual el dispositivo volvería a su estado de operación habitual.\newline

El cambio de estado de normal  al estado de alarma requiere primeramente de un proceso en la simulación que se encargue de generar alarmas para cada tipo de dispositivo, este proceso se caracteriza por una tasa de arribo de alarmas $ \lambda_{alarma}$. Esta tasa representa la cantidad promedio de alarmas por segundo que ocurrirán en el área de la célula, además de este parámetro se necesita especificar la velocidad a la que las alarmas se transmiten desde su lugar de origen.\newline

El siguiente proceso que propicia un cambio de estado, es el cálculo de la matriz de cambio de estado $P_n\left[k\right]$ que se lleva a cabo en cada dispositivo. La ecuación \ref{eqn:Pn} utiliza la información de cuándo y donde se produjeron eventos de alarma, además de su velocidad de propagación para determinar el momento en el que la alarma llega al dispositivo. Adicionalmente es necesario un modelo que caracterice la propagación espacial. Los modelos implementados fueron los propuestos en \parencite{Gupta2018} :\newline

\begin{equation}
\delta_n = e^{-\alpha.d_{n}}
\label{eqn:dn1}
\end{equation}

\begin{equation}
    \delta_n =
    \begin{cases}
        1  & \text{si $d_n < d_{th}$} \\
        \frac{1}{2}(1-sin\frac{\pi(d_n-W)}{2(W-d_{th})}) & \text{si $d_{th}< d_n < 2W-d_{th}$}\\
        0  & \text{si $d_n > 2W-d_{th}$}
    \end{cases}
    \label{eqn:dn2}
\end{equation}

El modelo que describe la \textit{ecuación~\ref{eqn:dn1}} se trata del decrecimiento exponencial y está pensado para simular alarmas cuyo efecto en los dispositivos se espera siga un comportamiento exponencial. Los tipos de dispositivos que utilicen este modelo deberán especificar la constante $\alpha$ que caracteriza al modelo. Por otra parte la \textit{ecuación~\ref{eqn:dn2}} se trata de una ventana de coseno alzado, esta función es útil para modelar alarmas que se transmiten fuertemente por cierta distancia pero que después se detienen abrúptamente. Los tipos de dispositivos que utilicen este segundo modelo deberán especificar las constantes $d_{th}$ y $W$, donde $W$ es el ancho de la ventana y $d_{th}$ es la distancia de corte. En ambas ecuaciones $d_n$ es la distancia del dispositivo al origen de la alarma.\newline

Expuesto esto, los parámetros necesarios para la generación de tráfico con el modelo CMMPP, los cuales variarán según se decida para cada tipo de dispositivo, se encuentran en la \textit{tabla~\ref{tab:ParametrosTraficoCMMPP}}.\newline

\begin{table}
    \caption{Parámetros necesarios para generar tráfico CMMPP}
    \label{tab:ParametrosTraficoCMMPP}
    \centering
    \begin{tabular}{|m{6cm}|p{10cm}|} \\ 
    \textbf{Parámetro} & \textbf{Descripción} \\ 
    \textit{Tasa de nacimiento de paquetes $\lambda_{normal}$}  & \footnotesize{ Media de nacimiento de paquetes por segundo en cada dispositivo } \\ \hline 
    \textit{Tasa de nacimiento de alarmas $\lambda_{alarma}$}  & \footnotesize{ Media de nacimiento de alarmas } \\ \hline 
    \textit{Velocidad de propagación de alarmas}  & \footnotesize{ Velocidad a la que se propaga una alarma desde su posición de origen hacia todas direcciones. } \\ \hline 
    \textit{Modelo de propagación espacial de las alarmas} & \footnotesize{ Ya sea decrecimiento exponencial o ventana de coseno alzado. } \\ \hline 
    \textit{Constante 1 propagación espacial} & \footnotesize{ Si el modelo de propagación corresponde a decrecimiento exponencial:
    se trata de la constante $\alpha$, factor de decaimiento.
    Si el modelo de propagación corresponde a ventana de coseno alzado:
    se trata de la constante $W$, ancho de la ventana. } \\ \hline 
    \textit{Constante 1 propagación espacial} & \footnotesize{ Si el modelo de propagación corresponde a decrecimiento exponencial:
    esta constante no se utiliza.
    Si el modelo de propagación corresponde a ventana de coseno alzado:
    se trata de la constante $d_{th}$, distancia de corte. } \\ \hline 
    \end{tabular}
\end{table}

    Con lo que respecta al tamaño de los paquetes, aquellos generados a partir del estado de alarma son de 20 $bytes$ y los generados en el estado normal siguen una distribución de Pareto con $\alpha$ = 2.5, tamaño mínimo de 20 $bytes$ y máximo de $200$ bytes.\newline

\subsection{Tráfico Periódico}

La generación del tráfico periódico no requiere mas que de un parámetro, la frecuencia de nacimiento de paquetes $F_{nacimiento}$, que es inversa al periodo de nacimiento de estos mismos $T_{nacimiento}$. En la implementación además, el tiempo del primer nacimiento de cada dispositivo que siga este modelo se calcula siguiendo una distribución uniforme que genera un valor entre 0 y el periodo de nacimiento y a partir de ahí se genera un nuevo nacimiento una vez transcurrido un periodo $T_{nacimiento}$. De esta manera, la transmisión de paquetes desde distintos dispositivos del mismo tipo se encuentra distribuida uniformemente a lo largo de un periodo.\newline

La \textit{tabla~\ref{tab:ParametrosTraficoPeriodico}} muestra el parámetro necesario para generar tráfico con el modelo periódico.\newline

\begin{table}
    \caption{Parámetros necesarios para generar tráfico Periódico}
    \label{tab:ParametrosTraficoPeriodico}
    \centering
    \begin{tabular}{|m{6cm}|p{10cm}|} \\ 
    \textbf{Parámetro} & \textbf{Descripción} \\ 
    \textit{Frecuencia de nacimiento de paquetes $F_{nacimiento}$}  & \footnotesize{ Cantidad de paquetes que genera un dispositivo por segundo, inversa al periodo entre dos nacimientos $T_{nacimiento}$. } \\ \hline 
 
    \end{tabular}
\end{table}

\subsection{Algoritmo de generación de tráfico fuente}

El programa de generación de tráfico fuente, implementa la generación de tráfico CMMPP y periódico según lo requiera cada tipo de dispositivo. El tráfico en cada tipo de dispositivo está caracterizado por los parámetros de entrada descritos en las \textit{tablas \ref{tab:ParametrosTraficoCMMPP} y \ref{tab:ParametrosTraficoPeriodico}}. Esta caracterización es compartida entre todos los dispositivos del mismo tipo, pero será diferente con dispositivos de otros tipos, según se seleccionen los parámetros.\newline

El \textit{algoritmo~\ref{generacionTrafico}} describe el proceso seguido por el programa de generación de tráfico.

\begin{algorithm}
    \caption{Generación de tráfico fuente}
    \label{generacionTrafico}
    \hspace*{\algorithmicindent} \textbf{Entrada} $T_{límite}$, $\Delta_{tiempo}$, $R_{célula}$, $S_1$, $S_2$, $S_3$, $S_4$, $S_5$, $S_6$, $S_7$, \\
    \hspace*{\algorithmicindent} \textbf{Salida} $ListaEventos$, $ListaDispositivos$
    \begin{algorithmic}[1]
    \Procedure{Generación de tráfico IoT}{}

    $Inicialización: $ \\
    $D=[ ]$, $G=[ ]$ // listas de dispositivos y generadores de alarmas
    \For{$i$ in range(1,8)} 
    \State // se crean los dispositivos especificados para cada servicio 
    \State$D$.append( crearDispositivos($S_i$,$R_{célula}$)) 
    \State// se crea un generador de alarma para cada servicio
    \State$G$.append( crearGeneradorAlarmas($S_i$,$R_{célula}$)) 
    
    \EndFor \\
$tiempo=0$ \\

// rutina principal
    \While{$tiempo < T_{límite}$}
        \For{$dispPorServicio$, $generadorAlarma$ in $D$, $G$} 

            \If{$tiempo==0$} 
            \State// se crea la primera alarma para cada servicio 
            \State$nuevaAlarma$ = $generadorAlarma$.generarAlarma($tiempo$) 
            
            \EndIf

            \For{dispositivo in dispPorServicio} 
            \State// ciclo que recorre cada dispositivo de un servicio
            \If{$dispositivo$.modeloTrafico == CMMPP}
            \State$dispositivo$.registrarAlarma(nuevaAlarma)
            \State$dispositivo$.calcularPnk($tiempo$,generadorAlarma)
            \State$dispositivo$.actualizarEstado()
            \State$dispositivo$.generarPaquete($tiempo$)
            \Else 
            \State$dispositivo$.generarPaquetePeriodico($tiempo$)
            
            \EndIf
            
            \EndFor
            \State$nuevaAlarma$ = $generadorAlarma$.generarAlarma($tiempo$)
        
        \EndFor 
        \State$tiempo+=\Delta_{tiempo}$ 
    
    \EndWhile \\
    $ListaEventos$ = $D$.ListaNacimientos\\
    $ListaDispositivos$ $D$.ListaDispositivos\\
    \EndProcedure
    \end{algorithmic}
\end{algorithm}

El \textit{algoritmo~\ref{generacionTrafico}} se programó en python 3.6 para realizar el escenario de pruebas y hacer inmediata su reutilización en el programa Generador de tráfico IoT. Los parámetros utilizados en el escenario de pruebas y sus resultados se encuentran en la siguiente sección.\newline

\subsection{Escenario de Prueba para la Generación de Tráfico}

El escenario de pruebas para el algoritmo de generación de tráfico considera los parámetros presentados en las \textit{tablas~\ref{tab:paramPruebaTrafico} y \ref{tab:paramPruebaTrafico2}}.  En la primera tabla se encuentran los parámetros que caracterizan el tráfico de los 7 distintos servicios seleccionados en la sección de diseño. Estos parámetros fueron determinados a partir de la \textit{tabla~\ref{tab:AppsSimulacion}}. Los demás parámetros necesarios para la simulación se encuentran en la segunda tabla, y corresponden al Tiempo de corte de la simulación y al diferencial $\Delta T$. Este diferencial corresponde al avance de tiempo que tiene la simulación en cada ciclo. Los valores se seleccionaron como $3600$ y $1$ segundos respectivamente, debido a que las tasas de nacimiento de paquete y de alarma se encuentran a lo más en el orden unas cuantas por minuto, de manera que no hay necesidad en tener una definición menor a 1 segundo. Algunas tasas de nacimiento de paquetes y alarmas se encuentran en el orden de unas cuantas por hora como es el caso de los dispositivos de detección de terremotos, razón por la cual se decidió realizar la simulación a lo largo de 3600 segundos.\newline

\begin{table}
    \caption{Parámetros para el escenario de pruebas de tráfico}
    \label{tab:paramPruebaTrafico}
    \centering
    \begin{tabular}{|m{16cm}|p{20cm}|} \\ 
        \textbf{Tipo:} Control de Iluminación\\ \textbf{Cantidad de dispositivos:} 1000 \\ \textbf{Modelo de tráfico:} CMMPP \\ \textbf{Tasa/Frecuencia de nacimiento de paquetes:} 0.000556  $paquetes/seg$. \\ \textbf{Tasa de nacimiento de alarmas:} 0.002778 $alarmas/seg$. \\ \textbf{Velocidad de alarma:} 500 $metros/seg$. \\ \textbf{Modelo de propagación espacial:} ventana de coseno alzado \\ \textbf{$W$:} 200 \\ \textbf{$d_{th}$:} 100 \\ \hline
        \textbf{Tipo:} Monitoreo del consumo de agua y electricidad \\ \textbf{Cantidad de dispositivos:} 500 \\ \textbf{Modelo de tráfico:} Periódico \\ \textbf{Tasa/Frecuencia de nacimiento de paquetes:} 0.001667  $paquetes/seg$. \\ \hline
        \textbf{Tipo:} Detección de terremotos\\ \textbf{Cantidad de dispositivos:} 500 \\ \textbf{Modelo de tráfico:} CMMPP \\ \textbf{Tasa/Frecuencia de nacimiento de paquetes:} 0.000278  $paquetes/seg$. \\ \textbf{Tasa de nacimiento de alarmas:} 0.002778 $alarmas/seg$. \\ \textbf{Velocidad de alarma:} 3000 $metros/seg$. \\ \textbf{Modelo de propagación espacial:} decrecimiento exponencial \\ \textbf{$\alpha$:} 0.4 \\ \hline
        \textbf{Tipo:} Monitoreo de contaminación del aire\\ \textbf{Cantidad de dispositivos:} 500 \\ \textbf{Modelo de tráfico:} Periódico \\ \textbf{Tasa/Frecuencia de nacimiento de paquetes:} 0.001111  $paquetes/seg$. \\ \hline
        \textbf{Tipo:} Control dinámico de semáforos\\ \textbf{Cantidad de dispositivos:} 1000 \\ \textbf{Modelo de tráfico:} Periódico \\ \textbf{Tasa/Frecuencia de nacimiento de paquetes:} 0.016667  $paquetes/seg$. \\ \hline
        \textbf{Tipo:} Otros dispositivos mMTC\\ \textbf{Cantidad de dispositivos:} 3000 \\ \textbf{Modelo de tráfico:} CMMPP \\ \textbf{Tasa/Frecuencia de nacimiento de paquetes:} 0.016667  $paquetes/seg$. \\ \textbf{Tasa de nacimiento de alarmas:} 0.033333 $alarmas/seg$. \\ \textbf{Velocidad de alarma:} 500 $metros/seg$. \\ \textbf{Modelo de propagación espacial:} decrecimiento exponencial \\ \textbf{$\alpha$:} 0.007  \\ \hline
        
    \end{tabular}
\end{table}

\begin{table}
    \caption{Parámetros para el escenario de pruebas de tráfico}
    \label{tab:paramPruebaTrafico2}
    \centering
    \begin{tabular}{|m{16cm}|p{20cm}|} \\ 
        \textbf{Tipo:} Dispositivos URLLC \\ \textbf{Cantidad de dispositivos:} 1000 \\ \textbf{Modelo de tráfico:} CMMPP \\ \textbf{Tasa/Frecuencia de nacimiento de paquetes:} 0.016667  $paquetes/seg$. \\ \textbf{Tasa de nacimiento de alarmas:} 0.033333 $alarmas/seg$. \\ \textbf{Velocidad de alarma:} 500 $metros/seg$. \\ \textbf{Modelo de propagación espacial:} \textit{Decaying exponential} \\ \textbf{$\alpha$:} 0.007  \\ \hline
        \textbf{Tiempo límite de simulación:} 3600 $segundos$ \\ \textbf{$\Delta T$:} 1 $segundo$ \\ \textbf{Radio de la célula:} 200 $metros$ \\ \hline
    \end{tabular}
\end{table}

Los resultados de la simulación se presentan en las siguientes gráficas las cuales muestran los histogramas de arribos para algunos servicios junto con de las distribuciones que estos siguen, además de algunos mapas de calor que muestran el comportamiento de la propagación espacial de las alarmas. \newline

\begin{figure}[th]
    \centering
    \includegraphics[scale=.55]{Figures/Otros_dispositivos_mMTC.png}
    \decoRule
    \caption[Otros dispositivos mMTC, Histograma de nacimientos y sus distribuciones]{Otros dispositivos mMTC, Histograma de nacimientos y sus distribuciones}
    \label{fig:histoeventos1}
\end{figure}

La \textit{figura~\ref{fig:histoeventos1}} contiene a la izquierda el histograma de  nacimiento de paquetes junto con el nacimiento de las alarmas para los dispositivos  del tipo Otros dispositivos mMTC. Las gráficas a la derecha por otra parte son más fáciles de interpretar y se trata de la distribuciones que sigue el tiempo entre nacimiento de paquetes y de alarmas, las cuales podemos ver  siguen una distribución exponencial a la tasas establecidas como parámetros en la  \textit{tabla~\ref{tab:paramPruebaTrafico}}, justo como se esperaba.\newline

\begin{figure}[th]
    \centering
    \includegraphics[scale=.55]{Figures/Semaforos_inteligentes.png}
    \decoRule
    \caption[Semáforos inteligentes, Histograma de nacimientos y sus distribuciones]{Semáforos inteligentes, Histograma de nacimientos y sus distribuciones}
    \label{fig:histoeventos2}
\end{figure}

La \textit{figura~\ref{fig:histoeventos2}} es muy parecida a la \textit{figura~\ref{fig:histoeventos1}} puesto que presenta las mismas gráficas, los histogramas a la izquierda y las distribuciones al derecha.  Pero en esta ocasión el servicio que observamos es el control de semáforos. Este servició genera  tráfico con el modelo periódico, razón por la cual el tiempo entre nacimiento de paquetes  es constante y no sigue una distribución exponencial.\newline

\hfill

\break

Finalmente en las \textit{figuras \ref{fig:propagacion1} y \ref{fig:propagacion2}} se ven los mapas de calor producidos por una alarma que se transmite siguiendo el modelo de ventana de coseno alzado y decrecimiento exponencial respectivamente. Se puede notar cómo la propagación de la alarma siguiendo el modelo de ventana de coseno alzado tiene lugar de manera más uniforme por dentro del círculo de radio dth  y con origen en su lugar de su nacimiento, para después terminar con un breve decaimiento, pero incluso se pueden ver varios puntos amarillos (mayor cantidad de alarmas) cerca de los límites de propagación. Por otro lado la alarma que sigue el modelo de decaimiento exponencial se desvanece desde su punto de origen y su efecto decae según crezca la distancia (de manera exponencial), en este caso por ejemplo no se tienen puntos amarillos alejados del origen (teniendo en cuenta la distancia a la que se propagó la alarma).\newline

\begin{figure}[th]
    \centering
    \includegraphics[scale=.7]{Figures/UEs_de_tipo_Control_de_iluminacion_activados_por_una_alarma.png}
    \decoRule
    \caption[Propagación de alarma en dispositivos de control de iluminación]{Propagación de alarma en dispositivos de control de iluminación}
    \label{fig:propagacion1}
\end{figure}

\begin{figure}[th]
    \centering
    \includegraphics[scale=.7]{Figures/UEs_de_tipo_Otros_dispositivos_mMTC_activados_por_una_alarma.png}
    \decoRule
    \caption[Propagación de alarma en otros dispositivos mMTC]{Propagación de alarma en otros dispositivos mMTC}
    \label{fig:propagacion2}
\end{figure}

Los resultados que presentan estas imágenes muestran que el algoritmo de generación de tráfico fuente está efectivamente generando arribos siguiendo los parámetros y modelos seleccionados, de manera que de aquí se procedió a su implementación en el programa \textbf{Generador de tráfico IoT} que se trata en la siguiente sección. \newline

\hfill

\break

%----------------------------------------------------------------------------------------
%	SECTION 
%----------------------------------------------------------------------------------------

\section{Generador de tráfico IoT} \label{generadortraficoiot}

    El Generador de tráfico IoT distribuye dispositivos IoT en una célula circular siguiendo un PPP, para después generar tráfico de estos dispositivos con los modelos CMMPP y Periódico. La rutina principal del programa sigue el paradigma \textit{time-driven}, puesto que realiza avances constantes en el tiempo. La salida del programa se da en forma de archivos .csv, de los cuales los dos más importantes son el archivo de dispositivos y el archivo de eventos. El archivo de dispositivos contiene información referente a cada uno de los dispositivos generados mientras que el archivo de eventos contiene la información del nacimientos de cada paquete.\newline

    La forma en que python se generaron y manipularon archivos .csv en python 3.6 fue con la librería $pandas$, la cual permite mapear listas a archivos .csv y viceversa. \newline

    Aunado a la funcionalidad principal del programa, se programó una interfaz de usuario para interactuar con el sistema e ingresar lo parámetros de la simulación. La interfaz de usuario se realizó con la librería $tkinter$. Esta interfaz se presenta con mayor detalle en la siguiente sección. \newline


\subsection{Interfaz de Usuario}

    La \textit{figura~\ref{fig:GUITrafico}} es una captura de pantalla de la interfaz de usuario del Generador de Tráfico IoT. En el primer bloque arriba a la izquierda se encuentran parámetros referentes a la distribución de usuarios, como son el radio del área circular en la que se distribuirán y su modelo de distribución. Los siguientes 7 bloques sirven para introducir los parámetros de generación de tráfico para los 7 distintos servicios contemplados. Finalmente se debe indicar hasta abajo: el tiempo de corte de la simulación y el diferencial de tiempo entre ciclos antes de poder iniciar la rutina. El botón de cargar datos abajo a la derecha permite leer los parámetros de un archivo y desplegarlos en las casillas correspondientes, lo que permite guardar una configuración inicial y acelerar la introducción de valores. \newline

    
\begin{figure}[th]
    \centering
    \includegraphics[scale=.65]{Figures/GUI.png}
    \decoRule
    \caption[Interfaz de Usuario, Generador de Tráfico IoT]{Interfaz de Usuario, Generador de Tráfico IoT}
    \label{fig:GUITrafico}
\end{figure}

\hfill

\break

Al terminar la rutina se generarán en la misma carpeta del programa 4 archivos .csv de los cuales 2 son utilizados en el \textbf{Simulador de eventos discretos}. Estos archivos son descritos con más detalle en la siguiente sección. \newline

\subsection{Archivos de Salida}

Los principales archivos que resultan de ejecutar cada rutina del Generador de Tráfico son el archivo de dispositivos y el archivo de eventos. En la \textit{figura~\ref{fig:archivodispositivos}} se puede ver un ejemplo del primer archivo, en él se guarda: a qué tipo de dispositivo corresponde cada servicio y su posición en el plano. Estos datos son después utilizados en el Simulador de eventos discretos para generar nodos del tipo especificado y poder adjudicarles sus nacimientos de paquetes. La \textit{figura~\ref{fig:archivoeventos}} muestra un ejemplo de archivo de eventos, en el cual encontramos los nacimientos de paquetes a lo largo del tiempo de simulación. Desde tal archivo se podrá conocer el dispositivo que originó el paquete, su tamaño y si éste surgió apartir de una alarma, todos estos datos importantes para que el simulador pueda procesar los eventos.  \newline

\begin{figure}[th]
    \centering
    \includegraphics[scale=.75]{Figures/disparchivo.png}
    \decoRule
    \caption[Archivo de dispositivos]{Archivo de dispositivos}
    \label{fig:archivodispositivos}
\end{figure}

\begin{figure}[th]
    \centering
    \includegraphics[scale=.75]{Figures/eventosarchivo.png}
    \decoRule
    \caption[Archivo de eventos]{Archivo de eventos}
    \label{fig:archivoeventos}
\end{figure}

Los últimos dos archivos resultados de cada rutina de este programa son el de configuración y el de alarmas. Pero estos no son utilizados por el Simulador de eventos, sino para generar gráficas de la distribución de usuarios y los modelos de tráfico y de distribución de alarmas.\newline

\hfill

\break


%----------------------------------------------------------------------------------------
%	SECTION 
%----------------------------------------------------------------------------------------

\section{Simulador de Eventos Discretos}

El Simulador de eventos discretos fue también programado en python 3.6 y sigue el paradigma de eventos discretos. La Inicialización del simulador se hace a travez de un archivo de configuración .json que permite modificar varios parámetros de la simulación sin necesidad de alterar el código.\newline

La funcionalidad básica del programa se puede observar en el diagrama de la \textit{figura~\ref{fig:flowdes}}. En el diagrama se puede ver que cuando se toma el siguiente evento en la cola, este es procesado y es aquí donde la mayor parte de la lógica del simulador recide. En la siguiente sección se describen los distintos eventos y cómo son procesados.\newline

\begin{figure}[th]
    \centering
    \includegraphics[scale=.7]{Figures/flowdes.png}
    \decoRule
    \caption[Simulación de eventos discretos]{Simulación de eventos discretos}
    \label{fig:flowdes}
\end{figure}

Para realizar la funcionalidad de eventos discretos en python se utilizó la librería $heapq$, la cual permite la utilización de \textit{heaps}, que son arboles binarios, para los cuales cada nodo padre tiene un valor menor o igual a cualquiera de sus hijos. De tal manera es posible mantener una lista que sigua esta estructura con el calendario de eventos (el arbol se ordena teniendo en cuenta el tiempo en el que ocurre el evento) y utilizar las funciones $heappush$ y $heappop$ para agregar nuevos eventos y removerlos del arbol respectivamente. Esta estructura asegura que el primer evento de la lista sea siempre el siguiente a ser evaluado y la librería representa una manera fácil de interactuar con la lista.\newline

A la salida del simulador, se tiene un archivo .csv con un historial de registros correspondiente a los eventos que fueron procesados además de otro archivo con el resultado de las probabilidades de bloqueo por falta de cluster, el porcentaje de paquetes que fueron transmitidos a la tasa deseada y el \textit{throughput} del sistema. Los eventos que tienen lugar y son procesados por el sistema se presentan en la siguiente sección. \newline 

\subsection{Descripción de los registros de salida}

La \textit{figura~\ref{fig:logsdes}} muestra una porción del archivo de registros resultante del Simulador de eventos discretos. En él se puede ver cúando y donde ocurrieron los eventos. Por ejemplo en el instante de tiempo 0 hubo el nacimiento de 5 paquetes provenientes de distintos dispositivos, cada uno de estos nacimientos propició que los dispositivos contendieran por recursos del canal, razón por la cual todos enviaron un preámbulo. Un instante de tiempo después se realiza el proceso noma con estos 5 dispositivos (no había más dispositivos utilizando el canal) y aquellos dispositivos que consiguieron recursos comienzan a transmitir. En el evento \textit{nuevo cluster} cada dispositivo que consiguió recursos imprime a qué cluster pertenece y a qué tasa transmite. Finalmente el último evento que se ve en la imagen muestrá cuantos dispositivos están transmitiendo a una tasa menor de la que requieren. \newline

\begin{figure}[th]
    \centering
    \includegraphics[scale=0.8]{Figures/logsdes.png}
    \decoRule
    \caption[Registros resultantes de una rutina]{registros resultantes de una rutina}
    \label{fig:logsdes}
\end{figure}

Con este archivo es posible ver cómo reaccionó el sistema en momentos específicos de la simulación. Con ayuda del archivo de eventos se puede analizar el comportamiento del sistema en distintas situaciones, como cuando ocurre una alarma y de pronto hay muchos nacimientos de paquetes o para ver cúanto tiempo después de estas el sistema se estabiliza por ejemplo. \newline

\subsection{Resultados a la salida del simulador}

A la salida del simulador se obtiene además del archivo con los \textit{logs} de los eventos que se evaluaron: El tráfico ofrecido, el \textit{throughput} del sistema, la probabilidad de bloqueo por negación de servicio (por falta de recursos, que ocurre cuando un dispositivo no alcanza lugar en algún cluster), y el porcentaje de tasas no cubiertas tanto para dispositivos mMTC como para dispositivos URLLC.

\hfill

\break

%----------------------------------------------------------------------------------------
%	SECTION 
%----------------------------------------------------------------------------------------

\section{Optimización de tiempos de simulación}

La técnica de paralelización se implementó pero sólamente en la generación de resultados de NOMA para un TTI ya que en esta parte fue que se necesitaron obtener resultados promedio donde cada punto o muestra de los datos necesitaba simularse 1000 repeticiones para así obtener un promedio. En la Figura~\ref{fig:SIMmultiprocessing} se observa la comparación de los tiempos de simulación en un caso normal (solamente 1 núcleo en uso) e implementando la paralelización (uso de todos los núcleos de la PC).\newline

Cabe mencionar que esta simulación se montó en una PC con procesador Intel(R) Core(TM) i7-7700HQ CPU @2.80 GHz y 16 GB de Memoria RAM.

\begin{figure}[th]
    \centering
    \includegraphics[scale=.7]{Figures/MultiprocesamientoSIM.png}
    \decoRule
    \caption[Gráfica de comparación de tiempos de simulación]{Gráfica de comparación de tiempos de simulación}
    \label{fig:SIMmultiprocessing}
\end{figure}