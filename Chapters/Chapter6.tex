% Chapter 6

\chapter{Implementación} % Main chapter title

\label{Chapter6} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

En este Captitulo se explica la implementación del modelo de sistema propuesto en el Capítulo \ref{Chapter5} \ldots

%----------------------------------------------------------------------------------------
%	SECTION 
%----------------------------------------------------------------------------------------

\section{Generación de una geometría estocastica implementando Procesos Puntuales de Poisson (PPP)}


\subsection{Escenario de Prueba de Procesos Puntuales de Poisson (PPP)}


%----------------------------------------------------------------------------------------
%	SECTION 
%----------------------------------------------------------------------------------------

\section{Generación de ganancias de canal implementando pérdidas PLE y desvanecimiento Rayleigh}
Por lo tanto como se lee en Seccion, en la actualidad el despliegue de redes NB-IoT se ha realizado en bandas de EUTRA (Acceso de radio en LTE). 

De acuerdo con el modelo de canal propuesto, el modelo CI \textit{Ecuación~\ref{eqn:CI}} \parencite{Sun2016} implementa pérdidas de acuerdo con la distancia dado un exponente de pérdida por trayectoria (PLE) y además, agrega pérdidas por el desvanecimiento rápido de Rayleigh.

Cuando se habla del desvanecimiento de Rayleigh en enlaces inalambricos, en la literatura \parencite{RayleighScienceDirect} se encuentra que las componentes en cuadratura y en fase de la señal recibida son variables aleatorias Gaussianas con media cero que se distribuyen de forma independiente e idéntica (iid), siendo así, que la magnitud de la señal banda base compleja sigue una distribución de Rayleigh. Por otra parte, la distribución de la potencia normalizada de una señal de banda base compleja recibida bajo el desvanecimiento unitario de Rayleigh es modelado por medio de una distribución exponencial unitaria.\newline

Por lo tanto, cuando el desvanecimiento es Rayleigh, la magnitud (voltaje) de la señal es distribuida por Rayleigh pero su potencia es distribuida exponencialmente.\newline

En nuestro caso, como se trabajará en términos de potencia, se modelará este fenómeno por medio de la generación de una variable aleatoria que siga una distribución exponencial negativa con media unitaria, es decir, para cada $x>=0$ :

\begin{equation}
    p(g>x)=e^{-x}
\end{equation}
$g \to ganancia\ en\ potencia\ del\ canal\ de\ desvanecimiento\ de\ Rayleigh$

\subsection{Escenario de Prueba del desvanecimiento tipo Rayleigh en potencia}


%----------------------------------------------------------------------------------------
%	SECTION 
%----------------------------------------------------------------------------------------

\section{Esquema de acceso múltiple al medio no ortogonal, basado en potencia (PD-NOMA)}

De acuerdo con el modelo de sistema (sección XXX), se propuso implementar un esquema de acceso múltiple no ortogonal (NOMA), con base en \parencite{Shahini2019}, los autores desarrollaron un esquema NOMA basado en NB-IoT por medio de un agrupamiento óptimo de los usuarios y una optimización en la asignación de recursos, de acuerdo con la maximización de la tasa de transmisión total de subida de los dispositivos MTC.\newline

\subsection{Algoritmo de Agrupación de dispositivos uRLLC  y mMTC}

Se implementó el algoritmo de agrupamiento NOMA para los dispositivos mMTC y uRLLC descrito en \parencite{Shahini2019}, este algoritmo realiza un ordenamiento conveniente con respecto al uso de la Cancelación Sucesiva de Interferencia (SIC), es decir, se ordenan los dispositivos URLLC y mMTC de acuerdo con su ganancia de canal promedio dentro de los diferentes grupos NOMA para que puedan compartir el mismo recurso espectral (subportadora) asignado a cada grupo.\newline

Por lo tanto, un mensaje combinado de los dispositivos mMTC y uRLLC con ruido aditivo es recibido en la BS, la BS emplea la recepción SIC de acuerdo en cómo son ordenados los dispositivos. \newline

La recepción SIC decodifica primero el mensaje del dispositivo con el rango más bajo, por consiguiente los usuarios con los rangos siguientes (o más altos) le introducen interferencia y a su vez el usuario con el rango más alto no experimenta interferencia de ninguna señal.\newline

Es importante notar que los dispositivos uRLLC tienen requerimientos de tasas de datos más altos, por lo tanto, su potencia de transmisión será mayor que la de los dispositivos mMTC. Es por esto que en cada grupo los dispositivos uRLLC tendrán los rangos más bajos y los dispositivos mMTC los mas altos. De hecho, el decodificador SIC en la BS comienza a decodificar con URLLC y, en consecuencia, los dispositivos mMTC no se ven afectados por la alta interferencia de los URLLC [véase Figura XXX].\newline


\subsection{Algoritmo de Asignacion de Subportadoras}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%       EJEMPLO DE ALGORITMO EN LaTeX       %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{itemize}
    \item U: Lista de dispositivos uRLLC
    \item M: Lista de dispositivoss mMTC
    \item S: Lista de Subportadoras s
    \item C: Lista de Grupos NOMA
    \item $R_{m}^{th}:$ Tasa objetivo del enésimo dispositivo m mMTC 
    \item $R_{u}^{th}:$ Tasa objetivo del enésimo dispositivo u uRLLC
    \item $P_{m}^{max}:$ Potencia máxima del enésimo dispositivo m mMTC (i.e. 23dBm)
    \item $P_{u}^{max}:$ Potencia máxima del enésimo dispositivo u uRLLC (i.e. 23dBm)
    \item $h_{m}^{s}:$ Ganancia de canal del enésimo dispositivo m mMTC sobre la portadora s
    \item $h_{u}^{s}:$ Ganancia de canal del enésimo dispositivo u uRLLC sobre la portadora s
    \item ${\hat S}$: Lista de subportadoras asignadas
    \item $S_{a}^{c}$: Lista de subportadoras asignadas al enésimo cluster
    \item ${C_{ns}}$: Lista de cluster con tasas insatisfechas
\end{itemize}


\makeatletter
% Reinsert missing \algbackskip
\def\algbackskip{\hskip-\ALG@thistlm}
\makeatother

\begin{algorithm}
    \caption{Algoritmo de agrupamiento de dispositivos uRLLC y mMTC para NOMA}\label{A1}
    \hspace*{\algorithmicindent} \textbf{Entrada} $U, M, S, C, h_{m}^{s} , \ and \ h_{u}^{s} ,\forall m \in \mathcal {M} , \forall u \in \mathcal {U} , \forall s \in \mathcal {S}$  \\
    \hspace*{\algorithmicindent} \textbf{Salida} Lista de Clusters (C) con agrupamiento de dispositivos 
    \begin{algorithmic}[1]
    \Procedure{Agrupación de dispositivos uRLLC}{}\\
    Cálculo de la ganancia de canal promedio del enésimo dispositivo u\\
    ${\tilde h_{u}} =\sum \nolimits _{s \in \mathcal {S}} {h_{u}^{s}}{/_{|S|}}$\\
    Se ordenan descendentemente las ganancias de canal promedio de cada dispositivo u, i.e. $\forall u \in \mathcal {U} : {\tilde h_{1}} \geq {\tilde h_{2}} \geq \cdots \geq {\tilde h_{U}}$ 
    \For{\textbf{each} u in U}
        \If {$|U|<|C|$} 
        \State Asignar uRLLC al rango mas bajo (k=1)
        \Else
        \State Asignar uRLLC al siguiente rango (k=2) [Solo se podrán asignar hasta un segundo rango]
        \EndIf
    \EndFor
    \State Encontrar ${\tilde k}$, rango y grupo en el que se quedó la última asignación uRLLC
    \EndProcedure
    \Procedure{Agrupación de dispositivos mMTC}{${\tilde k}$}\\
    Cálculo de la ganancia de canal promedio del enésimo dispositivo u\\
    ${\tilde h_{m}} =\sum \nolimits _{s \in \mathcal {S}} {h_{m}^{s}}{/_{|S|}}$\\
    Se ordenan descendentemente las ganancias de canal promedio de cada dispositivo u, i.e. $\forall m \in \mathcal {M} : {\tilde h_{1}} \geq {\tilde h_{2}} \geq \cdots \geq {\tilde h_{M}}$ 
    \For{\textbf{each} m in M}
        \If {$|M|<|C|$} 
        \State Asignar mMTC al rango ${\tilde k}$
        \Else
        \State Asignar mMTC al siguiente rango \ldots
        \EndIf
    \EndFor
    \EndProcedure
    \end{algorithmic}
\end{algorithm}


\begin{algorithm}
    \caption{Algoritmo de asignación de recursos para NOMA}\label{A2}
    \hspace*{\algorithmicindent} \textbf{Entrada} $U, M, S, C , R_{m}^{th} , R_{u}^{th} , P_{m}^{max} , P_{u}^{max} , h_{m}^{s} , \ and \ h_{u}^{s} ,\forall m \in \mathcal {M} , \forall u \in \mathcal {U} , \forall s \in \mathcal {S}$  \\
    \hspace*{\algorithmicindent} \textbf{Salida} Asignaciones de grupos con subportadoras (Asignación de todas las subportadoras [48, NB-IoT singletone]) 
    \begin{algorithmic}[1]
    \Procedure{Asignación de subportadoras}{}\\
    $Inicialización: $ \\${R_{u}} = 0 , {R_{m}} = 0 , p_{m}^{s}=P_{m}^{max} \ y \ p_{u}^{s}= P_{u}^{max} , \forall m \in \mathcal {M} , \forall u \in \mathcal {U} , \forall s \in \mathcal {S}.$ 
    ${\hat S} \leftarrow \emptyset,~~S_{a}^{c} \leftarrow \emptyset,~~{C_{ns}} \leftarrow \mathcal {C}$ 
    \While{$\mathcal{S} \ne \emptyset$}{}
    %\BState \emph{Asignación de subportadora a un grupo NOMA}:
        \For{\textbf{each} s in S}{
        \State Seleccionar al mejor cluster $c^{*}$ (el que maximiza el throughput):
        \State ${c^{*}} = \mathop {\arg \max }\limits _{c \in {C_{ns}}} \left ({{\sum \nolimits _{u \in \mathcal {U}} {R_{u} + \sum \nolimits _{m \in \mathcal {M}} {R_{m}} } } }\right) ;$ 
        \State donde: Ru \textit{(Ecuación \ref{eqn:Ru})} y Rm \textit{(Ecuación \ref{eqn:Rm})}
        \State $Asignar\ la\ subportadora\ s\ con\ c^{*} :$ 
        \State $Actualizar\ S_{a}^{c^{*}}\ \leftarrow S_{a}^{c^{*}} \cup \{ s\} , \hat S \leftarrow \hat S \cup \{ s\}$ 
        \State $Actualizar\ las\ tasas: {R_{u}} = {R_{u}} + {R_{u,s}} ,\ {R_{m}} = {R_{m}} + {R_{m,s}}$ 
        \State $Actualizar\ las\ potencias\ de\ los\ URLLC\ y\ mMTC\ de\ c^{*}\ individualmente:$ 
        \State $p_{m}^{s} = \frac {p_{m}^{s}}{{\left |{ {S_{a}^{c^{*}}} }\right | + 1}} ,\ p_{u}^{s} = \frac {p_{u}^{s}}{{\left |{ {S_{a}^{c^{*}}} }\right | + 1}} , \forall s \in \mathcal {S}$ 
        \If {$ S_{a}^{c^{*}} == 1$}{
        \State ${C_{ns}} \leftarrow {C_{ns}}\backslash \{{c^{*}}\}$ 
        \EndIf}
        \EndFor}
    \EndWhile
    \BState \emph{Asignación de subportadoras restantes}:
    \If {$ C_{ns} \ne \emptyset $} { 
        \For{\textbf{each} s in S}{
            \State $\mathcal {S} \leftarrow \mathcal {S}\backslash \hat S$ 
            \State ${c^{*}} = \mathop {\arg \max }\limits _{c \in {C}} \left ({{\sum \nolimits _{u \in \mathcal {U}} {R_{u} + \sum \nolimits _{m \in \mathcal {M}} {R_{m}} } } }\right)$ 
            \State $Actualizar\ S_{a}^{c^{*}} \leftarrow S_{a}^{c^{*}} \cup \{ s\}$ 
        \EndFor}
            \State $Actualizar\ p_{m}^{s} = \frac {p_{m}^{s}}{{\left |{ {S_{a}^{c^{*}}} }\right | + 1}} ,\ p_{u}^{s} = \frac {p_{u}^{s}}{{\left |{ {S_{a}^{c^{*}}} }\right | + 1}}$ 
    \EndIf}
    \EndProcedure
    \end{algorithmic}
\end{algorithm}


\subsection{Escenario de Prueba de los Algoritmos 1 y 2}

%----------------------------------------------------------------------------------------
%	SECTION 
%----------------------------------------------------------------------------------------

\section{Generación de Tráfico Fuente}

\subsection{Tráfico CMMPP}
\subsection{Escenario de Prueba de Tráfico CMMPP}

%----------------------------------------------------------------------------------------
%	SECTION 
%----------------------------------------------------------------------------------------

\section{Interconexión de los 4 módulos del Simulador}
%Incluir lo de NPRACHH, NPUCSH y NORA

%----------------------------------------------------------------------------------------
%	SECTION 
%----------------------------------------------------------------------------------------

\section{Simulador de Eventos Discretos}

\subsection{Definición de eventos}

\subsection{Interfaz de usuario}

\subsection{Descripción de los \textit{logs} de salida}

%----------------------------------------------------------------------------------------
%	SECTION 
%----------------------------------------------------------------------------------------

\section{Optimización de tiempos de simulación}

